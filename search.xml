<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Zookeeper + ZKUI 搭建分布式配置中心]]></title>
    <url>%2F2017-07-15%2FZookeeper%20%2B%20ZKUI%20%E6%90%AD%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.html</url>
    <content type="text"><![CDATA[当在一个集群规模的环境中，多台同类型的应用使用同样的配置文件，为了避免登陆每台机器修改配置，为了减少人为的修改导致配置不一致，为了实现配置文件的统一管理、版本控制，那么就有必要实现一个配置管理中心的应用。准备jdk环境maven环境Zookeeper安装下载https://www.apache.org/dyn/closer.cgi/zookeeper/解压1tar xvf zookeeper-3.4.13.tar.gz新增配置文件复制/zookeeper/conf/zoo_sample.cfg文件为zoo.cfg修改配置文件12345678910111213141516171819202122232425262728293031# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.# 数据文件夹dataDir=/usr/local/services/zookeeper/data# 日志文件夹dataLogDir=/usr/local/services/zookeeper/logs# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1Zookeeper启动启动之前若没有设置Jdk环境变量，则需要先修改zkServer.sh文件，在文件开头添加如下内容：12export JAVA_HOME=/usr/local/java # jdk安装目录export PATH=$JAVA_HOME/bin:$PATH手动启动123456789cd /# 启动/usr/local/services/zkServer.sh start# 停止/usr/local/services/zkServer.sh stop# 重启/usr/local/services/zkServer.sh restart# 查看状态/usr/local/services/zkServer.sh status快速启动新增环境变量，修改/etc/profile文件，在其尾部追加如下内容：1234# Zookeeper Homeexport ZOOKEEPER_HOME=/usr/local/services/zookeeperexport PATH=$ZOOKEEPER_HOME/bin:$PATHexport PATH新增环境变量后启动、停止、重启等操作就不需要指定可执行文件的路径，可在任意位置直接使用即可，如下：12345678# 启动zkServer.sh start# 停止zkServer.sh stop# 重启zkServer.sh restart# 查看状态zkServer.sh status开机自启在/etc/systemd/system目录下创建新建zookeeper.service文件，写入如下内容：1234567891011[Unit]Description=zookeeper.serviceAfter=network.target[Service]Type=forkingEnvironment=/usr/local/services/zookeeper/binExecStart=/usr/local/services/zookeeper/bin/zkServer.sh startExecStop=/usr/local/services/zookeeper/bin/zkServer.sh stopExecReload=/usr/local/services/zookeeper/bin/zkServer.sh restart[Install]WantedBy=multi-user.target完成后执行以下命令：1234# 重新加载服务systemctl daemon-reload# 设置开机自启动systemctl enable zookeeper.service其他操作命令：123456789101112# 重新加载配置信息systemctl daemon-reload# 启动zookeepersystemctl start zookeeper.service# 关掉zookeepersystemctl stop zookeeper.service# 查看进程状态及日志systemctl status zookeeper.service# 开机自启动systemctl enable zookeeper.service# 关闭自启动systemctl disable zookeeper.serviceZookeeper连接Zookeeper服务启动后，使用自带的客服端连接工具进行连接测试，执行命令：1zkCli.sh -server 127.0.0.1:2181查看目录：1ls /出现上面的结果则证明连接成功。注意如需在其他服务器上访问Zookeeper，需要开放对应的端口。Zkui安装下载https://github.com/DeemOpen/zkui解压12# 解压unzip zkui-master.zip编译12cd zkui-mastermvn clean install提示上面的解压，编译操作由于需要maven环境支持，所以服务器需要安装配置maven环境，在编译的过程中还要下载大量依赖jar包，如果服务器网络不好，会导致此过程很慢，所以我们可以在自己的开发环境进行编译的操作，完成后将源码根目录下的config.cfg和编译后的/target/zkui-2.0-SNAPSHOT-jar-with-dependencies.jar可执行jar文件上传至服务器即可。安装12mkdir /usr/local/services/zkuicp config.cfg target/zkui-2.0-SNAPSHOT-jar-with-dependencies.jar /usr/local/services/zkui修改配置文件123456# 服务端口serverPort=9090# zookeeper服务地址，如果是zookeeper集群则以逗号分割zkServer=192.168.255.1:2181,192.168.255.2:2181,192.168.255.3:2181# 管理界面登录帐号userSet = &#123;&quot;users&quot;: [&#123; &quot;username&quot;:&quot;admin&quot; , &quot;password&quot;:&quot;admin&quot;,&quot;role&quot;: &quot;ADMIN&quot; &#125;,&#123; &quot;username&quot;:&quot;appconfig&quot; , &quot;appconfig&quot;:&quot;&quot;,&quot;role&quot;: &quot;USER&quot; &#125;]&#125;Zkui启动1cd /usr/local/services/zkui &amp;&amp; nohup java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &amp;Zkui连接浏览器打开http://ip:port用配置文件中的账号密码登陆Zkui启用HTTPS生成keystore文件1234# 进入zukui目录cd /usr/local/services# 生成私钥，有效期为3650天keytool -genkey -v -alias jetty -keyalg RSA -storetype PKCS12 -validity 3650 -keystore ./keystore.jks修改config.cfg文件12345https=truekeystoreFile=/usr/local/services/zkui/keystore.jks# 生成私钥的口令keystorePwd=zkuiadminkeystoreManagerPwd=zkuiadmin重启服务Zookeeper配置中心Zkui导入配置配置文件为txt文本，使用Zkui导入到Zookeeper中，配置文件具体示例内容如下：12345678910111213# datasource/config/demo,dev=spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test/config/demo,dev=spring.datasource.username=root/config/demo,dev=spring.datasource.password=root/config/demo,dev=spring.datasource.driver-class-name=com.mysql.jdbc.Driver# redis/config/demo,dev=spring.redis.host=127.0.0.1/config/demo,dev=spring.redis.port=6379/config/demo,dev=spring.redis.password=admin# 其他配置# ...配置命名规则如下：1/&#123;node&#125;/&#123;application-name&#125;,&#123;profile&#125;=&#123;key&#125;=&#123;value&#125;其中{application-name}与{profile}之间用逗号分隔，也可以定义其他分隔符号，在项目的bootstrap文件中根据spring.cloud.zookeeper.config.profileSeparator指定。application文件要指定profile，它的值要和ZooKeeper配置中的{profile}一致。项目配置以SpringBoot项目为基础，新增zookeeper配置中心支持依赖，修改pom.xml：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-config&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;新建/src/main/resources/bootstrap.properties配置文件：12345678spring.profiles.active=devspring.application.name=spring-cloud-zookeeper-client-testspring.cloud.zookeeper.connect-string=192.168.255.1:2181,192.168.255.2:2181,192.168.255.3:2181spring.cloud.zookeeper.config.enabled=truespring.cloud.zookeeper.config.root=/configspring.cloud.zookeeper.config.profileSeparator=,ZooKeeper服务器配置除了zoo.cfg配置文件配置以外，也可也使用Java的zookeeper.propertyName名配置。当然那样不太方便了。最小化配置clientPort: 客户端端口dataDir: ZooKeeper的数据目录tickTime: 相当于心跳时间，ZooKeeper的最小时间单位。存储配置dataLogDir: ZooKeeper的事务日志存储的位置。默认和快照数据存储在同一个位置。建议尽量将两者分开。最好给事务日志一个单独的高性能磁盘，记录日志对磁盘性能要求非常高。snapCount: 仅支持Java系统属性配置,zookeeper.snapCount，两次快照之间的事务操作次数。默认值是10000preAllocSize: 默认是64MB。仅支持Java系统属性配置zookeeper.preAllocSize，如果频繁的进行快照，那么事务日志可能增长不到64MB，我们可以调整这个参数来优化存储traceFile：仅支持Java系统属性配置，requestTraceFile，开启日志调试。这个仅在开发环境下使用。traceFile文件名一般为traceFile.year.month.day。fsync.warningthresholdms： 单位为微秒，仅支持Java系统属性配置fsync.warningthresholdms，一旦进行一个fsync的操作大于此参数指定的时间，就在日志中打印报警信息。autopurge.snapRetainCount: 默认值为3，自动清理历史事务日志和快照数据的参数。清理日志后还剩余多少快照和事务日志文件。autopurge.purgeInterval: 默认值为0，单位是小时，不支持系统属性。与autopurge.snapRetainCount配套使用。如果值为0或者负数，代表不开启定时清理功能。syncEnabled: 3.4.6 版本中新引入的属性，使用Java系统属性配置，zookeeper. observer.syncEnabled，允许观察者记录事务日志和写入快照数据。 观察者不参与投票，但是可以提交方案。开启这个选项之后，减少观察者重启的时间。默认为true。网络配置globalOutstandingLimit: 默认值为1000，仅支持Java系统属性配置zookeeper.globalOutstandingLimit，配置ZooKeeper服务器最大请求的堆积数量，也就是服务器同时处理的请求数。maxClientCnxns： 默认值为60，不支持Java系统属性配置，单个客户端和单台服务器之间的并发连接数。如果设置为0，代表不限制。3.4.0之前这个参数都是10，3.4.0版本以后开始变成了60.clientPortAddress：不支持Java系统属性配置，监听客户端连接的地址和端口，如果有多个网卡，可以指定不同的监听端口。minSessionTimeout: 最小的超时时长限制，为tickTime的整数倍。默认为2maxSessionTimeout：最大超时时长。 默认为20集群配置electionAlg：不支持Java系统属性，用于选举实现，默认值是3，其它的0，1，2都是要弃用的。initLimit：没有Java系统属性，时间数量，单位是ticks，默认值为10. 该参数为Leader服务器等待Follwer服务器启动，并完成数据同步的时间，Leader允许Follower在这个时间内完成工作。如果集群数量过于庞大，可以适当增加这个参数。syncLimit：不支持Java系统属性配置，默认值为5。Leader服务器和Follwer服务器进行心跳检测的最大延时时间。如果再这个心跳时间内无法收到Follower的心跳信息，那么Leader就认为该Follower已经脱离了和自己的同步。leaderServes：仅支持Java系统属性配置，zookeeper.leaderServes默认值为yes，只能配置伪yes或no。设置Leader服务器是否支持客户端的连接，若设置为no，那么leader服务器只专注于进行分布式协调。cnxTimeout：默认值为5000，单位为毫秒。仅支持系统属性配置zookeeper.cnxTimeout，用于在Leader选举的时候，各服务器之间进行TCP创建连接的超时时间。server.x=[hostname]:port1[:port2] : 不支持Java配置。用于配置组成ZooKeeper集群的机器列表。其中x为Server ID，与每台服务器myid文件中的数字相对应。第一个端口指定Follower与Leader进行通信和数据同步的端口。第二个端口用于选举过程中的投票通信。使用建议周期性的清理事务日志文件和快照文件。 可以设置autopurge选项ZooKeeper使用Log4j来记录日志，可以使用Log4j的自动滚动日志特性客户端连接ZooKeeper服务器列表的时候，最好对应ZooKeeper服务器的列表，否则可能会有砌块的事情发生。ZooKeeper服务器集群中的服务器列表保持一致事务日志文件最好存在在单独的磁盘上，这样可以更好的发挥ZooKeeper的性能项目代码SpringCloud-Zookeeper：https://github.com/amorous/SpringCloud-Zookeeper]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章 分布式开发与SpringCloud简介]]></title>
    <url>%2F2017-04-15%2F%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B8%8ESpringCloud%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[第一章 分布式开发与SpringCloud简介一、分布式开发简介​ 当有了第一台电脑之后就开始有人去想到如何将不同的电脑进行网络连接，而有了网络连接之后对于项目的开发就开始有了所谓的分布式设计，从最初的设计来讲，重要的数据肯定是要保存多份的。所以对于分布式的要求就逐步形成了。​ 实际上经过了这么多年的发展，很多的人开始认识到一个问题：单台主机所能处理的数据量是有限的，所以为了得到更高性能的设计方案一定要采用多台主机，可是这多台主机之间该如何进行分配呢？​ 于是对于分布式的开发设计，最初就有了以下的几点思考？分布式的开发如何可疑让代码更加安全？分布式开发的时候如何进行有效的通讯？在进行分布式处理的时候到底如何进行程序的功能划分？现在对于很多有经验的开发工程师来说实际上都已经清楚的知道了现在项目开发之中要进行的分布式的设计：WEB集群：考虑到多用户的并发访问的处理速度；业务中心：在进行一些庞大的醒目设计过程之中，应该有更加完善的业务处理，这样所有的客户端（服务器）直接调用这些业务中心的操作就可以完成具体的功能；数据库集群：解决了数据的存储问题，以及数据的分片管理。对于分布式的项目开发按照历史的发展经历过如下的一些技术：CORBA：公共对象请求代理架构，它是一种开发的标准，而且也是许多语言都支持的开发标准。RMI（远程方法调用）：该技术是SUN提出的，该技术出现的最大特征死希望可以与CORBA进行市场竞争，于是这个时候出现了一个问题：很多的公司不认可这项技术；在Java里面提出了远程接口的概念，不过RMI的实现有些糟心；后来SUN的设计师发现，RMI很好用，但是不如CORBA广泛，于是开始思考能否基于CORBA做一些更好的设计呢？这样就产生了一个新的协议：RMI-IIOP协议，而这个协议用在EJB技术上；EJB留给世界的只是它优秀的理论，和它糟糕的实现，并且这个理论被一些开源框架无限制的扩充与实现着。.NET出现了，而后又因为J#的问题，微软和SUN就彻底决裂了，后来行业就乱了，因为有两套企业架构，公司就面临选择，于是尴尬的局面出现了，选择谁？后来软件行业继续推广，同时出现了一款优秀语言：XML，很多的公司就觉得应该用XML作为数据交换的基础，这个时候著名的软件架构：WebService登场了。如果你的项目之中想要使用WebService技术进行开发，则有如下问题：速度太慢了，处理的速度不行；如果想要采用远程接口的方式调用，则要利用开发工具生成一堆的工具类代码；后来2005年的时候WebService在市面上继续发酵，形成了又一大核心神器：SOA（面向服务架构）。它提出了一个企业服务总线（ESB）的概念。SOA提出的服务总线又成为了新一代分布式的讨论需求，人们发现如果将所有的服务统一管理起来，就成为了服务总线，那么所有的开发者直接调用里面的服务就完成一些功能。后来又不断出现了许多的RPC开发技术，其中在国内具有代表性的的dubbo开噶技术。不过这个时候成长最快的是Rest，因为JSON的广泛应用，就如同最初XML技术造就了WebService一样，JSON造就了Rest服务，人们认为我们的操作应该更加简单一些，Rest还是一个未成型的标准还在发展着，而随着Rest技术的广泛任何，Spring终于得到了一个新的机会：利用Rest进行RPC技术实现，这样的操作速度很快，而且占用的带宽要少。在SpringCloud之中就真正的将整个的Rest作为了RPC实现技术，并且这一技术已经开始出现有行业的统一之势。而且SpringCloud也依照于SpringBoot开发技术，可以实现项目的打包发布以及单独运行，这一点都符合于当前云时代的开发要求。二、SpringCloud开发架构​ SpringCloud整体核心架构只有一点：Rest服务，也就是说在整个SpringCloud配置过程之中，所有的配置处理都是围绕着Rest完成的，在整个Rest处理之中，一定要有两个端：服务的提供者（Provider）、服务的消费者（Consumer），所以对于整个SpringCloud的基础结构就如下所示：​ 既然SpringCloud的核心是Restful结构，那么如果要想更好的去使用Rest这些为服务还需要考虑如下几个问题？所有的为服务的地址一定会非常的多，所以为了统一管理这些地址信息，也为了可以及时的告诉用户哪些服务不可用，应该准备一个分布式的注册中心，并且该注册中心应该支持有HA机制，为了高速并且方便的进行所有服务的注册操作，在SpringCloud里面提供有一个Eureka的注册中心；对于整个的WEB端的架构（SpringBoot实现）可以轻松方便的进行WEB程序的编写，而后利用Nginx或Apache实现负载均衡处理，但是现在WEB端出现了负载均衡，那么业务端呢？应该也提供有多个业务端进行负载均衡。那么这个时候就需要将所有需要参与到负载均衡的业务端在Eureka之中进行注册。在进行客户端使用Rest架构调用的时候，往往都需要一个调用地址，即时现在使用了Eureka作为注册中心，那么它也需要有一个明确的调用地址，可是所有的操作如果都利用调用地址的方式来处理，不是很方便，开发者最方便应用的工具死接口，所以就希望可以将所有的Rest服务的内容以接口的方式调用，所以它又提供了一个Feign技术，利用此技术可以伪造接口实现。在进行整体的微架构设计的时候由于牵城到的问题还是RPC，所以就必须考虑熔断处理机制，实际上所谓的熔断就好比实际生活之中使用的保险丝一样，有了保险丝在一些设备出现了故障之后依然可以保护家庭电器可以正常使用，如果说现在有若干个微服务，并且这些微服务之间允许互相调用，例如：A微服务调用了B微服务、B微服务又调用了C的微服务；如果在实际的项目设计过程之中没有处理好熔断机制，那么就会产生雪崩效应，为了防止这样的问题出现，SpringCloud里面提供有一个Hystrix熔断处理机制，以保证某一个微服务即时出现了问题之后依然可以正常使用。在进行微服务访问的时候还有一点是非常可怕的。通过Zuul的代理用户只需要知道指定的路由的路径就可以访问指定的微服务的信息，这样更好的提现了Java中的“key=value”的设计思想，而且所有的微服务通过Zuul进行代理之后也可以更加合理的进行名称的隐藏。在SpringBoot学习的时候一直强调过一个问题：在SpringBoot里面强调的是一个“零配置”的概念，本质在不需要编写任何的配置文件，但是事实上这一点并没有完全的实现，因为在整体的设计里面，依然会提供有application.yml（application.properties）配置文件，那么如果在微服务的创建之中，那么一定会有成百上千个微服务的信息出现，于是这些配置文件的管理就成为了问题，例如：现在突然有一天你的主机要进行变更，所有的服务的IP地址都可能发生改变，这样对于程序的维护是不方便的，为了解决这样的问题，在SpringCloud设计的时候提供有SpringCloudConfig的程序组件，利用这个组件就可以直接基于Git或Svn来进行配置文件的管理。在整体设计上SpringCloud更好的实现了RPC的架构设计，而且使用乐Rest作为通讯的基础，这一点是它的成功之处，同时由于大量的使用了netflix公司的产品技术，所以这些技术也有可靠的保证。]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat内置过滤器详解]]></title>
    <url>%2F2017-03-27%2FTomcat%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[Tomcat提供了许多过滤器，这些过滤器可以在全局配置文件 $CATALINA_BASE/conf/web.xml中使用，表示对当前Tomcat容器中所有项目同时开启；也可以在各个Web应用程序配置文件 WEB-INF/web.xml中进行配置，表示仅对当前配置项目生效。每个过滤器如下所述（基于Tomcat 8.0版本）。一、AddDefaultCharsetFilter描述HTTP规范清楚地表明了，如果没有为“text”媒体类型的媒体子类型指定字符集，但是，浏览器可能会尝试自动检测字符集。攻击者可能利用此漏洞执行XSS攻击。默认情况下，Internet Explorer是开启自动检测字符集的。其他浏览器可以选择性启用。此过滤器通过显式设置字符集来防止攻击。除非用户显式覆盖提供的字符集，否则浏览器将遵循显式设置的字符集，从而防止XSS攻击。过滤器类名1org.apache.catalina.filters.AddDefaultCharsetFilter初始化参数属性描述encoding如果Servlet没有设置其他字符集，则需要设置的字符集的名称。此参数有两个特殊值 default和system。值system 使用JVM范围的默认字符集，通常由locale设置。default将使用ISO-8859-1。配置示例123456789101112&lt;filter&gt; &lt;filter-name&gt;addDefaultCharsetFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.AddDefaultCharsetFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;system&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;addDefaultCharsetFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;使用场景防止XSS攻击二、CorsFilter描述CorsFilter跨域资源共享规范的一个实现，常常用于前后端分离，静态资源与后端分离等情况。它主要在HttpServletResponse中增加Access-Control-*头，同时保护HTTP响应避免拆分，如果请求无效或者禁止访问，则返回403响应码。过滤器类名1org.apache.catalina.filters.CorsFilter初始化参数属性描述cors.allowed.origins允许访问的跨域资源列表。*表示允许访问来自任何域的资源，多个域用”,”分隔。例如：https://www.w3.org, https://www.apache.org。 默认值：空字符串（禁止访问资源）。cors.allowed.methods可以用于访问资源的HTTP方法列表，”,”分隔，用于跨域请求。这些方法将出现在Prefligh（预检请求）响应头Access-Control-Allow-Methods的一部分，默认值： GET, POST, HEAD, OPTIONScors.allowed.headers构造请求时可以使用的请求头，以”,”分隔，这些方法将包含在Prefligh（预检请求）响应头Access-Control-Allow-Headers内。默认值：Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headerscors.exposed.headers浏览器允许访问的头部信息列表，”,”分隔。这些方法将包含在Prefligh（预检请求）响应头Access-Control-Allow-Headers内。默认值：无。默认情况下不公开非简单标头cors.preflight.maxage浏览器允许缓存的Preflght请求结果的时间，单位为秒。如果为负数，则表示CorsFilter不会添加头到Preflight响应，这些方法将包含Prefligh（预检请求）响应头Access-Control-Max-Age内。默认值： 1800cors.support.credentials表示资源是否支持用户证书，这些方法将包含在Prefligh（预检请求）响应头Access-Control-Allow-Credentials内，它可以帮助浏览器确定是否可以使用凭据进行实际请求。默认值： falsecors.request.decorate用于控制是否应将CORS特定属性添加到HttpServletRequest对象。默认值： true；如果cors.request.decorate初始化参数为 true：则设置以下属性：cors.isCorsRequest：用于确定请求是否为CORS请求的标志；cors.request.origin：Origin URL，即发出请求的页面的URL；cors.request.type：CORS请求的类型。可能的值：SIMPLE: 非Preflight请求为先导的请求；ACTUAL: 以Preflight请求为先导的请求；PRE_FLIGHT: Preflight请求；NOT_CORS: 正常同域请求；INVALID_CORS: 无效的域请求。cors.request.headers: 作为Preflight请求Access-Control-Request-Header头发送的请求头信息配置示例1234567891011121314151617181920212223242526272829303132&lt;filter&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.methods&lt;/param-name&gt; &lt;param-value&gt;GET,POST,HEAD,OPTIONS,PUT&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.headers&lt;/param-name&gt; &lt;param-value&gt;Content-Type,X-Requested-With,accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.exposed.headers&lt;/param-name&gt; &lt;param-value&gt;Access-Control-Allow-Origin,Access-Control-Allow-Credentials&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.support.credentials&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.preflight.maxage&lt;/param-name&gt; &lt;param-value&gt;10&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;使用场景处理跨域请求三、CsrfPreventionFilter描述该过滤器为Web应用程序提供基本的CSRF保护。如果过滤器映射到/*并且返回到客户端的所有URL都通过调用HttpServletResponse#encodeRedirectURL(String)或 编码 HttpServletResponse#encodeURL(String)。实现机制是生成一个nonce并且将其保存到session中，URL的encode也使用同样的nonce，当请求到达时，会比较请求中的nonce和session中的token是否一致，只有相同的才允许继续执行。过滤器类名1org.apache.catalina.filters.CsrfPreventionFilter初始化参数属性描述denyStatus（tomcat7.0之后新增）拒绝请求时使用的HTTP响应状态代码，默认值：403entryPoints以“,”为分隔的URL列表，这项配置用来做类似于exclude的功能，在配置中的映射，可以跳过检查nonceCacheSize随机数缓存大小。预生成的随机数被缓存到一个LRU缓存中以支持并发请求，用于浏览器刷新等行为（可能导致随机数不是当前的），默认值：5randomClass用于生成随机数的类的名称。该类必须是一个继承自java.util.Random的实例，默认值：java.security.SecureRandom配置示例1234567891011121314151617181920&lt;filter&gt; &lt;filter-name&gt;CsrfPreventionFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.CsrfPreventionFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;denyStatus&lt;/param-name&gt; &lt;param-value&gt;403&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;entryPoints&lt;/param-name&gt; &lt;param-value&gt;/html,/css,/js&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;nonceCacheSize&lt;/param-name&gt; &lt;param-value&gt;5&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CsrfPreventionFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;使用场景用于CSRF安全过滤处理四、RestCsrfPreventionFilter描述该过滤器为REST APIs提供基本的CSRF保护。CSRF保护仅适用于非（GET、HEAD、OPTIONS）的HTTP修改请求。它基于一个自定义头X-CSRF-TOKEN和一个有效的nonce实现。REST API的CSRF保护机制包括以下步骤：客户端要求提供有效的随机数。这是通过对受保护资源的非修改“获取”请求来执行的。服务器使用映射到当前用户会话的有效随机数进行响应。客户端在同一用户会话的帧中的后续修改请求中提供此随机数。服务器拒绝对不包含有效nonce的受保护资源的所有修改请求。过滤器类名1org.apache.catalina.filters.CsrfPreventionFilter初始化参数六、FailedRequestFilter描述用于触发请求的参数解析，如果由于解析错误或请求大小限制（例如 Connector中的maxParameterCount属性 ）而在参数解析期间跳过某些参数，则拒绝请求 。此过滤器可用于确保客户端提交的任何参数值都不会丢失。该过滤器的原理是：先调用ServletRequest.getParameter（首次调用会触发Tomcat服务器的请求参数解析，如果参数解析失败，将结果放到请求属性org.apache.catalina.parameter_parse_failed中），之后判断属性org.apache.catalina.parameter_parse_failed的值，如果不为空则直接返回400，以下是源码解析：123456789private boolean isGoodRequest(ServletRequest request) &#123; // Trigger parsing of parameters request.getParameter("none"); // Detect failure if (request.getAttribute(Globals.PARAMETER_PARSE_FAILED_ATTR) != null) &#123; return false; &#125; return true;&#125;为了能正确解析参数，需要该Filter之前设置字符集编码过滤器SetCharacterEncodingFilter。过滤器类名1org.apache.catalina.filters.FailedRequestFilter初始化参数无配置示例12345678&lt;filter&gt; &lt;filter-name&gt;failedRequestFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.FailedRequestFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;failedRequestFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;使用场景用于对请求参数有严格限制时的后台处理。十三、SetCharacterEncodingFilter描述提供了一种设置字符集编码的方式，通常情况下默认ISO-8859-1编码，但实际生产环境推荐使用UTF-8编码，此过滤器可通过配置强制改变请求的编码方式，本质上这个过滤器调用 ServletRequest.setCharacterEncoding()方法。此过滤器只针对POST请求中的参数有效，因此我们需要在参数解析之前进行数据编码处理，所以经常会把此过滤器的顺序放在最前面，GET请求的编码不是在这里设置的，而是在server.xml文件中的Connector节点上设置。过滤器类名1org.apache.catalina.filters.SetCharacterEncodingFilter初始化参数属性描述encoding要设置的字符编码。ignore表示是否忽略客户端请求设置的字符集编码，如果为true那么都会将请求字符集编码覆盖，如果为false，仅会当请求没有指定字符集编码时才会进行设置。默认值：false配置示例123456789101112&lt;filter&gt; &lt;filter-name&gt;setCharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.SetCharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;setCharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;使用场景用于处理POST请求中参数包含中文时，中文乱码的问题。]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ超详细教程]]></title>
    <url>%2F2017-03-21%2FRabbitMQ%E8%B6%85%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[前言1、为什么使用RabbitMQ为什么我开始选择学习RabbitMQ：安装部署简单，上手门槛低，功能丰富，符合AMQP标准；企业级消息队列，经过大量实践考验的高可靠；集群易扩展，可以轻松的增减集群节点；有强大的WEB管理页面。企业为什么将RabbitMQ作为消息队列系统：十万米高空看RabbitMQ：有商业化的运营，不会轻易死掉；遵循AMQP协议，不会被绑架；强大的社区支持，为技术进步提供动力；大量成功的应用案例，例如阿里、网易等互联网巨头都有使用。显微镜看RabbitMQ：Erlang开发，AMQP的最佳搭档，在支持持久化的消息队列中性能算很优秀的；支持消息持久化、支持消息确认机制、灵活的任务分发机制等，支持功能非常丰富；可靠性高；集群扩展很容易，并且可以通过增加节点实现成倍的性能提升；WEB管理和监控，有些技术癌更喜欢命令行界面，但WEB管理为后期运维提供很大的便利。RabbitMQ劣势： 在kafka和zero面前性能被虐成渣，（持久化消息和ACK确认的情况下生产和消费消息单机大约在1-2万左右）结论：如果你希望使用一个可靠性高、功能强大、易于管理的消息队列系统那么就选择RabbitMQ吧，如果你想用一个性能高，但偶尔丢点数据不是很在乎可以使用kafka或者zeroMQ。2、RabbitMQ产生的背景1、消息队列系统最在可以追溯到上个世纪。1983年最早的消息队列软件Teknekron诞生，当时紧用于一些金融交易等系统。2、上世纪九十年代，诞生了多家消息队列系统，例如IBM MQ、微软的MSMQ、TIBCO MQ等消息队列在企业中的应用也愈加广泛。显然这些商用的消息队列系统如果企业要使用需要付出高昂的成本，并且各个消息队列之间使用不同的API不同的协议。3、2004年，AMQP（Advanced Message Queuing Protocol,高级消息队列协议）开始开发。通过这一标准可以和任意AMQP供应商提供的MQ服务进行交互。4、2006年，光阴荏苒时光如梭，一转眼就说到了重点。我们的主角使用Erlang语言实现的AMQP开源版本，RabbitMQ诞生了，同年AMQP协议首次发布。3、为什么叫RabbitMQ？兔子行动非常迅速而且繁殖起来也非常疯狂，所以就把Rabbit用作这个分布式软件的命名（就是这么简单）。一、RabbitMQ的安装全文讲解的是在winodws10下的安装使用1、下载安装erlang下载erlang，原因在于RabbitMQ服务端代码是使用并发式语言erlang编写的，下载地址：http://www.erlang.org/downloads，双击.exe文件进行安装就好。下载完成后双击打开，一直next就可以，不再描述安装完成之后创建一个名为ERLANG_HOME的环境变量，其值指向erlang的安装目录。同将%ERLANG_HOME%\bin加入到Path中最后打开命令行，输入erl，如果出现erlang的版本信息就表示erlang语言环境安装成功。2、下载安装RabbitMQ点击RabbitMQ官网下载地址，进入下载页面：选择对应的下载链接：安装路径不能有空格，默认的安装路径是有空格的，请注意：3.7.4之后版本是无需理会安装空格的。3、激活 RabbitMQ’s Management Plugin安装RabbitMQ-Plugins，这个相当于是一个管理界面，方便我们在浏览器界面查看RabbitMQ各个消息队列以及exchange的工作情况。进入RabbitMQ的安装目录并以管理员身份运行cmd命令：输入指令激活插件：rabbitmq-plugins.bat enable rabbitmq_management​ 输入指令启动RabbitMQ服务：net start RabbitMQ常用命令：启动服务：net start RabbitMQ停止服务：net stop RabbitMQ重启服务：net stop RabbitMQ &amp;&amp; net start RabbitMQ4、登录验证浏览器访问：http://localhost:15672，默认用户名和密码：guest5、配置允许远程访问更多情况下，队列服务往往不在我们本机上，我们需要远程来控制RabbitMQ，但是默认是无法通过http://server-name:15672来访问的，可以通过修改\RabbitMQ Server\rabbitmq_server-3.6.10\etc下Rabbitmq.config来设置允许guest用户远程登录，具体修改为如下，然后就到服务管理器中重启RabbitMQ服务。默认RabbitMQ会在C:\Users\Administrator\AppData\Roaming\RabbitMQ 中生成一个配置文件，rabbitmq.config 里面就是实际用到的配置信息，如果图方便，也可以这里直接改。1[&#123;rabbit, [&#123;loopback_users, [guest]&#125;]&#125;].二、RabbitMQ概念producer：消息生产者consumer：消息消费者virtual host：虚拟主机，在RabbitMQ中，用户只能在虚拟主机的层面上进行一些权限设置，比如我可以访问哪些队列，我可以处理哪些请求等等；broker：消息转发者，也就是我们RabbitMQ服务端充当的功能了，那么消息是按照什么规则进行转发的呢？需要用到下面几个概念；exchange：交换机，他是和producer直接进行打交道的，有点类似于路由器的功能，主要就是进行转发操作的呗，那么producer到底用哪个exchange进行路由呢？这个取决于routing key(路由键)，每个消息都有这个键，我们也可以自己设定，其实就是一字符串；queue：消息队列，用于存放消息，他接收exchange路由过来的消息，我们可以对队列内容进行持久化操作，那么queue到底接收那个exchange路由的消息呢？这个时候就要用到binding key(绑定键)了，绑定键会将队列和exchange进行绑定，至于绑定方式，RabbitMQ提供了多种方式；以上就是RabbitMQ涉及到的一些概念了，用一张图表示这些概念之间的关系就是：三、用户角色权限、virtual hosts配置1、用户管理​ 我们在开发的时候一般不直接使用guest账号进行操作，而是新增一个新的管理用户进行操作，那么怎么新增帐号呢？首先使用guest帐号登录管理控制台如上图点击Admin菜单并点击Add a user操作就会出现用户名和密码以及确认密码、Tags（相当于角色）的输入框。输入后点击左下方的Add user按钮即可完成新增用户的操作，新增成功后会在Admin页面列表中出现我们新增的用户。2、角色管理RabbitMQ中的角色分为如下五类：none、management、policymaker、monitoring、administratornone ：不能访问 management pluginmanagement ：用户可以通过AMQP做的任何事外加：列出自己可以通过AMQP登入的virtual hosts查看自己的virtual hosts中的queues, exchanges 和 bindings查看和关闭自己的channels 和 connections查看有关自己的virtual hosts的“全局”的统计信息，包含其他用户在这些virtual hosts中的活动。policymaker ：management可以做的任何事外加： 查看、创建和删除自己的virtual hosts所属的policies和parametersmonitoring ：management可以做的任何事外加：​ 列出所有virtual hosts，包括他们不能登录的virtual hosts​ 查看其他用户的connections和channels​ 查看节点级别的数据如clustering和memory使用情况​ 查看真正的关于所有virtual hosts的全局的统计信息administrator ：policymaker和monitoring可以做的任何事外加:​ 创建和删除virtual hosts​ 查看、创建和删除users​ 查看创建和删除permissions​ 关闭其他用户的connections3、virtual hosts像mysql有数据库的概念并且可以指定用户对库和表等操作的权限。那RabbitMQ呢？RabbitMQ也有类似的权限管理。在RabbitMQ中可以虚拟消息服务器VirtualHost，每个VirtualHost相当月一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的。exchange、queue、message不能互通。在RabbitMQ中无法通过AMQP创建VirtualHost，可以通过以下命令来创建。如上图在创建完vhost后可以在All Virtual Host标签看到新建的VirtualHost。4、virtual hosts授权在用户列表界面点击我们需要授权的用户，出现如下界面：然后选择指定的Virtual Host进行授权，授权完成后我们回到Admin页面如下：四、RabbitMQ - 简单队列一个生产者对应一个消费者！！！生产者将消息发送到“hello”队列。消费者从该队列接收消息。接下来我们将用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。1、新建Maven项目，添加RabbitMQ客户端和 (SLF4J API and SLF4J Simple)的依赖包1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.dj&lt;/groupId&gt; &lt;artifactId&gt;rabbitmq&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;rabbitmq&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;jdk.version&gt;1.8&lt;/jdk.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.26&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;rabbitmq&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;$&#123;jdk.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;jdk.version&#125;&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;2、创建获取连接工具类：ConnectionUtils.java12345678910111213141516171819202122import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;public class ConnectionUtils &#123; public static Connection getConnection() throws IOException, TimeoutException &#123; //1、定义连接工厂 ConnectionFactory connectionFactory = new ConnectionFactory(); //2、设置服务器地址 connectionFactory.setHost("127.0.0.1"); //3、设置端口 connectionFactory.setPort(5672); //4、设置VirtualHost、用户名及密码 connectionFactory.setVirtualHost("/virtual_test"); connectionFactory.setUsername("djtest"); connectionFactory.setPassword("djtest"); //5、获取并返回连接 return connectionFactory.newConnection(); &#125;&#125;3、创建消息发送者：Send.java1234567891011121314151617181920212223242526272829import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class Send &#123; //定义队列名称 private static final String QUEUE_NAME = "simple_queue"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明(创建)队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、定义消息内容 String message = "Hello World!"; //5、发布消息 channel.basicPublish("", QUEUE_NAME, null, message.getBytes("UTF-8")); System.out.println("[x] Sent'" + message + "'"); //6、关闭通道 channel.close(); //7、关闭连接 connection.close(); &#125;&#125;此时我们直接运行消费者的main方法，结果如下：1[x] Sent&apos;Hello World!&apos;查看管理界面Queue页面结果如下：4、创建消息消费者：Recv.java12345678910111213141516171819202122232425262728293031323334import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class Recv &#123; //定义队列名称 private static final String QUEUE_NAME = "simple_queue"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; //6、获取消息 System.out.println(new String(body, "utf-8")); &#125; &#125;; //5、监听队列 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125;消费者代码编写完成后运行，控制台打印结果如下：1Hello World!查看管理界面Queue页面结果会发现我们之前发布的消息已经被消费：五、RabbitMQ – Work Queue（工作队列）1、Round-robin dispatching（轮询分发）一个生产者对应多个消费者，但是只能有一个消费者获得消息！！！竞争消费者模式。接下来用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的多个消费者。1、创建消息发送者：Send.java123456789101112131415161718192021222324252627282930313233import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class Send &#123; //定义队列名称 private static final String QUEUE_NAME = "work_queue"; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明(创建)队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、定义消息内容(发布多条消息) for (int i = 0; i &lt; 10; i++) &#123; String message = "I am work_queue " + i; //5、发布消息 channel.basicPublish("", QUEUE_NAME, null, message.getBytes("utf-8")); System.out.println(" [x] Sent '" + message + "'"); //模拟发送消息延时，便于演示多个消费者竞争接受消息 Thread.sleep(i * 10); &#125; //6、关闭信道 channel.close(); //7、关闭连接 connection.close(); &#125;&#125;2、创建消息消费者1：Recv_1.java每接收一条消息后休眠10毫秒123456789101112131415161718192021222324252627282930313233343536373839import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class Recv_1 &#123; //定义队列名称 private static final String QUEUE_NAME = "work_queue"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; //6、获取消息 System.out.println(new String(body, "utf-8")); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; //5、监听队列 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125;3、创建消息消费者2：Recv_2.java每接收一条消息后休眠1000毫秒12345678910111213141516171819202122232425262728293031323334353637383940import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class Recv_2 &#123; //定义队列名称 private static final String QUEUE_NAME = "work_queue"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; //6、获取消息 System.out.println(new String(body, "utf-8")); //消费者2接收一条消息后休眠1000毫秒 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; //5、监听队列 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125;4、测试结果生产者一次打印从0-9条消息12345678910[x] Sent &apos;I am work_queue 0&apos;[x] Sent &apos;I am work_queue 1&apos;[x] Sent &apos;I am work_queue 2&apos;[x] Sent &apos;I am work_queue 3&apos;[x] Sent &apos;I am work_queue 4&apos;[x] Sent &apos;I am work_queue 5&apos;[x] Sent &apos;I am work_queue 6&apos;[x] Sent &apos;I am work_queue 7&apos;[x] Sent &apos;I am work_queue 8&apos;[x] Sent &apos;I am work_queue 9&apos;消费者1：结果为打印偶数条消息12345I am work_queue 0I am work_queue 2I am work_queue 4I am work_queue 6I am work_queue 8消费者2：结果为打印奇数条消息12345I am work_queue 1I am work_queue 3I am work_queue 5I am work_queue 7I am work_queue 95、分析结果消费者1和消费者2获取到的消息内容是不同的，也就是说同一个消息只能被一个消费者获取。消费者1和消费者2分别获取奇数条消息和偶数条消息，两种获取消息的条数是一样的。前面我们说这种模式是竞争消费者模式，一条队列被多个消费者监听，这里两个消费者，其中消费者1和消费者2在获取消息后分别休眠了10毫秒和1000毫秒，也就是说两个消费者获取消息的效率是不一样的，但是结果却是两者获得的消息条数是一样的，这根本就不构成竞争关系，那么我们应该怎么办才能让工作效率高的消费者获取消息更多，也就是消费者1获取消息更多呢？PS：在增加一个消费者其实获取消息条数也是一样的，消费者1获取0、3、6、9，消费者2获取1、4、7，消费者3获取2、5、8每个消费者将获得相同数量的消息。这种分发消息的方式称为循环法。2、Fair dispatch（公平分发）根据结果分析我们得知，如果，我们单个消费者1分钟最多处理60条消息，但是，生产者1分钟可能会发送300条消息，如果，我们一台消费者客户端，1分钟同时要接收到300条消息，已经超过我们最大的负载，这时，就可能导致，服务器资源被耗尽，消费者客户端卡死等情况。然而，RabbitMQ对此却一无所知，仍然会均匀的发送消息。发生这种情况是因为RabbitMQ只是在消息进入队列时调度消息。它不会查看消费者未确认消息的数量。它只会盲目的把第n个消息发送给第n个消费者。为了改变这种模式，RabbitMQ提供了一种qos（服务质量保证）功能，即在非自动确认消息的前提下，如果一定数目的消息（通过基于consume或者channel设置Qos的值）未被确认前，不进行消费新的消息。我们可以使用basicQos方法和prefetchCount = 1设置。这告诉RabbitMQ在处理并确认前一个消息之前，不要向该消费者发送新消息，它会将它发送给下一个仍然很忙的工人。123456789com.rabbitmq.client.Channel： void basicQos(int prefetchCount) throws IOException; void basicQos(int prefetchCount, boolean global) throws IOException; void basicQos(int prefetchSize, int prefetchCount, boolean global) throws IOException;// prefetchSize：服务器将传递的最大内容量（以八位字节为单位），如果不受限制，则为0// prefetchCount：服务器将传递的最大消息数，如果不受限制，则为0，简单点说，就是会告诉RabbitMQ不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有ack，则该consumer将block掉，直到有消息ack// global：true\false 是否将上面设置应用于channel，简单点说，就是上面限制是channel级别的还是consumer级别12int prefetchCount = 1 ; channel.basicQos（prefetchCount）;生产者和消费者同时增加如上代码，表示同一时刻服务器只会发送一条消息给消费者。发现消费者1和消费者2获取消息结果还是如之前那样，这是为什么呢，是因为prefetchCount在autoAsk=false的情况下生效，即在自动应答的情况下这两个值是不生效的，而我们之前的消费端代码是使用的自动应答模式。1、创建消息发送者：Send.java12345678910111213141516171819202122232425262728293031323334353637import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class Send &#123; //定义队列名称 private static final String QUEUE_NAME = "work_queue_fair"; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明(创建)队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、限制每个消费者同时最多能处理1条消息 int prefetchCount = 1; channel.basicQos(prefetchCount); //5、定义消息内容(发布多条消息) for (int i = 0; i &lt; 10; i++) &#123; String message = "I am work_queue " + i; //6、发布消息 channel.basicPublish("", QUEUE_NAME, null, message.getBytes("utf-8")); System.out.println(" [x] Sent '" + message + "'"); //模拟发送消息延时，便于演示多个消费者竞争接受消息 Thread.sleep(i * 10); &#125; //7、关闭信道 channel.close(); //8、关闭连接 connection.close(); &#125;&#125;2、创建消息消费者1：Recv_1.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class Recv_1 &#123; //定义队列名称 private static final String QUEUE_NAME = "work_queue_fair"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、保证一次只处理一个 int prefetchCount = 1; channel.basicQos(prefetchCount); //5、定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; //7、获取消息 System.out.println(new String(body, "utf-8")); try &#123; //消费者1接收一条消息后休眠10毫秒 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //手动应答 channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125; &#125;; //6、监听队列-关闭自动应答 boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); &#125;&#125;3、创建消息消费者2：Recv_2.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class Recv_2 &#123; //定义队列名称 private static final String QUEUE_NAME = "work_queue_fair"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、保证一次只处理一个 int prefetchCount = 1; channel.basicQos(prefetchCount); //5、定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; //7、获取消息 System.out.println(new String(body, "utf-8")); //消费者2接收一条消息后休眠1000毫秒 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //手动应答 channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125; &#125;; //6、监听队列-关闭自动应答 boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); &#125;&#125;4、测试结果生产者一次打印从0-9条消息12345678910[x] Sent &apos;I am work_queue 0&apos;[x] Sent &apos;I am work_queue 1&apos;[x] Sent &apos;I am work_queue 2&apos;[x] Sent &apos;I am work_queue 3&apos;[x] Sent &apos;I am work_queue 4&apos;[x] Sent &apos;I am work_queue 5&apos;[x] Sent &apos;I am work_queue 6&apos;[x] Sent &apos;I am work_queue 7&apos;[x] Sent &apos;I am work_queue 8&apos;[x] Sent &apos;I am work_queue 9&apos;消费者1123456789I am work_queue 0I am work_queue 2I am work_queue 3I am work_queue 4I am work_queue 5I am work_queue 6I am work_queue 7I am work_queue 8I am work_queue 9消费者21I am work_queue 15、应用场景效率高的消费者消费消息多。可以用来进行负载均衡。PS：如果所有消费者都很忙，队列就会填满。那么将需要考虑添加更多消费者，或者创建更多的virtualHost来细化你的设计，或者采取其他策略。六、Exchanges（交换机）交换器分为四种，分别是：direct、fanout、topic和 headers。前面三种分别对应路由模式、发布订阅模式和通配符模式，headers 交换器允许匹配 AMQP 消息的 header 而非路由键，除此之外，header 交换器和 direct 交换器完全一致，但是性能却差很多，因此基本上不会用到该交换器，这里也不详细介绍。1、direct如果路由键完全匹配的话，消息才会被投放到相应的队列。direct是RabbitMQ默认的交换机模式，也是最简单的模式，根据key全文匹配去寻找队列。2、fanout当发送一条消息到fanout交换器上时，它会把消息投放到所有附加在此交换器上的队列。不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。发送消息，只需要指定交换机，route key 可以为空3、topic设置模糊的绑定方式，“*”操作符将“.”视为分隔符，匹配单个字符；“#”操作符没有分块的概念，它将任意“.”均视为关键字的匹配部分，能够匹配多个字符。七、RabbitMQ – Publish/Subscribe（发布/订阅模式）在之前的案例中都是同一个消息都只能被一个消费者消费，如果现在同一个消息需要向多个消费者传递信息，那么就需要使用到Publish/Subscribe（发布/订阅）。以下构建一个注册成功后发送邮件和短信通知的例子。RabbitMQ中消息传递模型的核心思想是生产者永远不会将任何消息直接发送到队列。实际上，生产者通常甚至不知道消息是否会被传递到任何队列。相反，生产者只能向exchange（交换机）发送消息。exchange一方面接收来自生产者的消息，另一方面将它们推送到队列。exchange必须确切知道如何处理它收到的消息。它应该附加到特定队列吗？它应该附加到许多队列吗？或者它应该被丢弃。其规则由交换类型定义 。在RabbitMQ中有几种交换类型可供选择：direct、topic、headers、fanout，接下来的列子我们讲使用“fanout”这种类型，并将其称为 “fanout_exchange”。1channel.exchangeDeclare("fanout_exchange", "fanout");1、创建消息发送者：Send.java1234567891011121314151617181920212223242526272829import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class Send &#123; //定义交换机名称 private static final String EXCHANGE_NAME = "fanout_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明交换机 channel.exchangeDeclare(EXCHANGE_NAME, "fanout"); //4、定义消息内容 String message = "注册成功"; //5、发布消息 channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes("utf-8")); System.out.println(" [x] Sent '" + message + "'"); //6、关闭信道 channel.close(); //7、关闭连接 connection.close(); &#125;&#125;此时我们先测试运行发送者代码，然后通过管理界面可以看到我们的交换机创建成功了，如下图：但是此时并没有看到队列，如下图：发现此时我们的消息丢失了，因为交换机没有存储的能力，在RabbitMQ里面只有队列有存储能力，由于这时候还没有队列绑定到这个交换机，所以数据丢失了。2、创建消息消费者1：Recv_1.java123456789101112131415161718192021222324252627282930313233343536373839import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class Recv_1 &#123; //定义队列名称 private static final String QUEUE_NAME = "ps_queue_email"; //定义交换机名称 private static final String EXCHANGE_NAME = "fanout_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、将队列绑定到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); //5、定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; //6、获取消息 System.out.println(new String(body, "utf-8") + " - 开始发送email通知"); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; //7、监听队列-关闭自动确认 channel.basicConsume(QUEUE_NAME, false, consumer); &#125; &#125;3、创建消息消费者2：Recv_2.java123456789101112131415161718192021222324252627282930313233343536373839import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class Recv_2 &#123; //定义队列名称 private static final String QUEUE_NAME = "ps_queue_sms"; //定义交换机名称 private static final String EXCHANGE_NAME = "fanout_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、将队列绑定到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); //5、定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; //6、获取消息 System.out.println(new String(body, "utf-8") + " - 开始发送短信通知"); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; //7、监听队列-关闭自动确认 channel.basicConsume(QUEUE_NAME, false, consumer); &#125; &#125;4、测试结果生产者1[x] Sent &apos;注册成功&apos;消费者112[*] Waiting for messages. To exit press CTRL+C注册成功 - 开始发送email通知消费者212[*] Waiting for messages. To exit press CTRL+C注册成功 - 开始发送短信通知管理页面5、应用场景比如一个商城系统需要在管理员上传商品新的图片时，前台系统必须更新图片，日志系统必须记录相应的日志，那么就可以将两个队列绑定到图片上传交换器上，一个用于前台系统更新图片，另一个用于日志系统记录日志。八、RabbitMQ – Routing（路由模式）生产者将消息发送到direct交换器，在绑定队列和交换器的时候有一个路由key，生产者发送的消息会指定一个路由key，那么消息只会发送到相应key相同的队列，接着监听该队列的消费者消费消息。也就是让消费者有选择性的接收消息。1、创建消息发送者：Send.java123456789101112131415161718192021222324252627282930import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class Send &#123; //定义交换机名称 private static final String EXCHANGE_NAME = "direct_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明交换机 channel.exchangeDeclare(EXCHANGE_NAME, "direct"); //4、定义消息内容 String message = "橙色"; //5、发布消息 String routingKey = "oranger"; channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes("utf-8")); System.out.println(" [x] Sent '" + message + "'"); //6、关闭信道 channel.close(); //7、关闭连接 connection.close(); &#125;&#125;2、创建消息消费者1：Recv_1.java12345678910111213141516171819202122232425262728293031323334353637383940import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class Recv_1 &#123; //定义队列名称 private static final String QUEUE_NAME = "routing_queue"; //定义交换机名称 private static final String EXCHANGE_NAME = "direct_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、将队列绑定到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "oranger"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "green"); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); //5、定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; //6、获取消息 System.out.println(" [Recv_1] - " + new String(body, "utf-8")); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; //7、监听队列-关闭自动确认 channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125;3、创建消息消费者2：Recv_2.java123456789101112131415161718192021222324252627282930313233343536373839import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class Recv_2 &#123; //定义队列名称 private static final String QUEUE_NAME = "routing_queue"; //定义交换机名称 private static final String EXCHANGE_NAME = "direct_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、将队列绑定到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "black"); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); //5、定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; //6、获取消息 System.out.println(" [Recv_1] - " + new String(body, "utf-8")); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; //7、监听队列-关闭自动确认 channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125;4、测试结果我们首先看代码，生产者发布消息，指定的路由key为oranger。消费者1绑定队列和交换机时key分别是oranger/green；消费者2绑定队列和交换器时key是black。所以我们可以猜测生产者发送的消息，只有消费者1能够接收并消费，而消费者2是不能接收的。生产者1[x] Sent &apos;橙色&apos;消费者112[*] Waiting for messages. To exit press CTRL+C[Recv_1] - 橙色消费者21[*] Waiting for messages. To exit press CTRL+C5、应用场景利用消费者能够有选择性的接收消息的特性，比如我们商城系统的后台管理系统对于商品进行修改、删除、新增操作都需要更新前台系统的界面展示，而查询操作确不需要，那么这两个队列分开接收消息就比较好。九、RabbitMQ – Topics（主题模式）生产者将消息发送到topic交换器。上面的路由模式是根据路由key进行完整的匹配（完全相等才发送消息），这里的通配符模式通俗的来讲就是模糊匹配。符号“#”表示匹配一个或多个词，符号“*”表示匹配一个词。1、创建消息发送者：Send.java12345678910111213141516171819202122232425262728293031323334353637import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class Send &#123; //定义交换机名称 private static final String EXCHANGE_NAME = "topic_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明交换机 channel.exchangeDeclare(EXCHANGE_NAME, "topic"); //4、定义消息内容 String messageByAdd = "新增用户"; //5、发布消息 String routingKeyByAdd = "user.add"; channel.basicPublish(EXCHANGE_NAME, routingKeyByAdd, null, messageByAdd.getBytes("utf-8")); System.out.println(" [x] Sent '" + messageByAdd + "'"); //4、定义消息内容 String messageByDel = "新增用户"; //5、发布消息 String routingKeyByDel = "user.delete"; channel.basicPublish(EXCHANGE_NAME, routingKeyByDel, null, messageByDel.getBytes("utf-8")); System.out.println(" [x] Sent '" + messageByDel + "'"); //6、关闭信道 channel.close(); //7、关闭连接 connection.close(); &#125;&#125;2、创建消息消费者1：Recv_1.java123456789101112131415161718192021222324252627282930313233343536373839import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class Recv_1 &#123; //定义队列名称 private static final String QUEUE_NAME = "topic_queue_1"; //定义交换机名称 private static final String EXCHANGE_NAME = "topic_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、将队列绑定到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "user.add"); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); //5、定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; //6、获取消息 System.out.println(" [Recv_1] - " + new String(body, "utf-8")); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; //7、监听队列-关闭自动确认 channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125;3、创建消息消费者2：Recv_2.java123456789101112131415161718192021222324252627282930313233343536373839import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class Recv_2 &#123; //定义队列名称 private static final String QUEUE_NAME = "topic_queue_2"; //定义交换机名称 private static final String EXCHANGE_NAME = "topic_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; //1、获取连接 Connection connection = ConnectionUtils.getConnection(); //2、声明信道 Channel channel = connection.createChannel(); //3、声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //4、将队列绑定到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "user.#"); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); //5、定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; //6、获取消息 System.out.println(" [Recv_1] - " + new String(body, "utf-8")); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; //7、监听队列-关闭自动确认 channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125;4、测试结果生产者发布消息绑定的路由key为user.add和user.delete。消费者1绑定队列和交换机绑定路由key为user.add；消费者2绑定队列和交换机绑定路由key为user.#。所以我们可以猜测生产者发送的消息，消费者1能够接收并消费新增用户的消息，而消费者2能接收新增和删除用户的消息。生产者12[x] Sent &apos;新增用户&apos;[x] Sent &apos;删除用户&apos;消费者11[Recv_1] - 新增用户消费者212[Recv_1] - 新增用户[Recv_1] - 删除用户十、RabbitMQ - 消息应答ack机制1、创建消息发送者：Send.java123456789101112131415161718192021import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class Send &#123; private static final String EXCHANGE_NAME = "simple_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, "fanout", false); String message = "ack_test"; channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes("utf-8")); System.out.println(" [x] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125;2、自动应答-创建消息消费者：RecvAutoAck.java12345678910111213141516171819202122232425262728293031import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class RecvAutoAck &#123; private static final String QUEUE_NAME = "simple_queue"; private static final String EXCHANGE_NAME = "simple_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(" [Recv_1] - " + new String(body, "utf-8")); &#125; &#125;; //开启自动应答机制 boolean autoAck = true; channel.basicConsume(QUEUE_NAME, autoAck, consumer); &#125;&#125;3、手动应答-创建消息消费者：RecvBasicAck.java123456789101112131415161718192021222324252627282930313233import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class RecvBasciAck &#123; private static final String QUEUE_NAME = "simple_queue"; private static final String EXCHANGE_NAME = "simple_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(" [Recv_1] - " + new String(body, "utf-8")); //手动应答 channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; //关闭自动应答机制 boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); &#125;&#125;方法1：basicAck（确认收到一个或多个消息）123//deliveryTag：该消息的index//multiple：是否批量.true：将一次性ack所有小于deliveryTag的消息void basicAck(long deliveryTag, boolean multiple) throws IOException;方法2：basicReject（拒绝一条收到的消息-单条拒绝）123//deliveryTag:该消息的index//requeue：被拒绝的是否重新入队列void basicReject(long deliveryTag, boolean requeue) throws IOException;方法3：basicNack（拒绝一条或多条收到的消息-批量拒绝）1234//deliveryTag:该消息的index//multiple：是否批量.true:将一次性拒绝所有小于deliveryTag的消息。//requeue：被拒绝的是否重新入队列void basicNack(long deliveryTag, boolean multiple, boolean requeue) throws IOException;方法4：basicRecover（重新发送到队列中）12//requeue：被拒绝的是否重新入队列Basic.RecoverOk basicRecover(boolean requeue) throws IOException;4、注意123456789Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg &apos;durable&apos; for queue &apos;simple_queue&apos; in vhost &apos;/virtual_test&apos;: received &apos;false&apos; but current is &apos;true&apos;, class-id=50, method-id=10) at com.rabbitmq.client.impl.ChannelN.asyncShutdown(ChannelN.java:516) at com.rabbitmq.client.impl.ChannelN.processAsync(ChannelN.java:346) at com.rabbitmq.client.impl.AMQChannel.handleCompleteInboundCommand(AMQChannel.java:182) at com.rabbitmq.client.impl.AMQChannel.handleFrame(AMQChannel.java:114) at com.rabbitmq.client.impl.AMQConnection.readFrame(AMQConnection.java:672) at com.rabbitmq.client.impl.AMQConnection.access$300(AMQConnection.java:48) at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:599) at java.lang.Thread.run(Thread.java:748)以上异常是由于修改了队列的应答模式，需要删除之前的队列，或者重新定义新的队列，因为队列和交换机的一些属性一旦定义，就不允许修改。十一、RabbitMQ - 消息的持久性在正常的服务器运行过程中，时常会面临服务器宕机重启的情况，那么我们的消息此时会如何呢？很不幸的事情就是，我们的消息可能会消失，这肯定不是我们希望见到的结果。所以我们希望AMQP服务器崩溃了也可以将消息恢复，这称之为消息持久化。RabbitMQ自然存在这种策略可以帮助我们完成这件事情。如果我们希望即使在RabbitMQ服务重启的情况下，也不会丢失消息，我们可以将Queue、Exchange与Message都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的RabbitMQ消息不会丢失。当然还是会有一些小概率事件会导致消息丢失。1、交换机持久化创建消息发送者代码：Send.java1234567891011121314151617181920212223import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class Send &#123; private static final String EXCHANGE_NAME = "simple_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); //声明交换机-并开启交换机的持久化策略 boolean durable = true; channel.exchangeDeclare(EXCHANGE_NAME, "fanout", durable); String message = "exchange_durable_test"; channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes("utf-8")); System.out.println(" [x] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125;关闭交换机持久化策略：12boolean durable = false;channel.exchangeDeclare(EXCHANGE_NAME, "", durable);开启交换机持久化策略：12boolean durable = true;channel.exchangeDeclare(EXCHANGE_NAME, "", durable);测试结果设置durable = false时;运行Send.java，进入控制台我们可以看到我们刚刚创建交换机，然后执行rabbitmq-service stop命令停止RabbitMQ服务，再执行 rabbitmq-service start命令启动RabbitMQ服务，进入控制台我们可以发现刚刚我们创建的交换机消失了。设置durable = true;重复上述步骤，我们可以发现我们的交换机持久化策略已经生效。2、队列持久化创建消息发送者代码：Send.java（引用上一步的代码）创建消息消费者代码：Recv.java1234567891011121314151617181920212223242526272829303132import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;import com.rabbitmq.client.AMQP.BasicProperties;import cn.dj.rabbitmq.util.ConnectionUtils;public class Recv &#123; private static final String QUEUE_NAME = "simple_queue"; private static final String EXCHANGE_NAME = "simple_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); //声明队列-并开启队列的持久化策略 boolean durable = false; channel.queueDeclare(QUEUE_NAME, durable, false, false, null); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); DefaultConsumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(" [Recv_1] - " + new String(body, "utf-8")); channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125;关闭队列持久化策略：12boolean durable = false;channel.queueDeclare(QUEUE_NAME, durable, false, false, null);开启队列持久化策略：12boolean durable = true;channel.queueDeclare(QUEUE_NAME, durable, false, false, null);测试结果设置durable = false时;运行Recv.java，进入控制台我们可以看到我们刚刚创建交换机，然后执行rabbitmq-service stop命令停止RabbitMQ服务，再执行 rabbitmq-service start命令启动RabbitMQ服务，进入控制台发现刚刚创建的队列依然存在，这是为什么呢，已经关闭了持久化策略，原因是我们的消费端还一直处于监听队列的状态，再我们重启RabbitMQ之后立马又帮我们声明了这个队列，那如果消费端也宕机了，我们这里先关闭消费端的监听，再重启查看，发现果然如预想的一样，队列已经不存在了。设置durable = true;重复上述步骤，发现我们的队列依然存在，队列持久化策略已经生效。简单队列和Work Queue由于没有使用到交换机，所以队列的声明是在发送者端完成的；Publish/Subscribe、Routing、Topics由于用到了交换机，所以队列的声明在消费者端，消费者端再将各自的队列绑定到交换机；这两种情况都不影响队列的持久化，它们的持久化策略和方式都是一样的。3、消息持久化修改消息发送者代码：Send.java1234567891011121314151617181920212223242526272829import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.AMQP;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class Send &#123; //定义交换机名称 private static final String EXCHANGE_NAME = "simple_exchange"; public static void main(String[] args) throws IOException, TimeoutException &#123; Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); //声明交换机-并开启交换机的持久化策略 boolean durable = true; channel.exchangeDeclare(EXCHANGE_NAME, "fanout", durable); String message = "durable_test"; //传送模式-标记持久化 int deliveryMode = 2; AMQP.BasicProperties basicProperties = new AMQP.BasicProperties().builder().deliveryMode(deliveryMode).build(); channel.basicPublish(EXCHANGE_NAME, "", basicProperties, message.getBytes("utf-8")); System.out.println(" [x] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125;AMQP.BasicProperties 提供了一个构造器，可以通过builder() 来设置一些属性；可以通过AMQP.BasicProperties 来设置消息的一些属性，更多属性设置参见官方API文档。运行上一个例子的Send.java时，重启RabbitMQ服务后发现我们发布的消息消失了，运行本例，重启RabbitMQ服务后消息依然存在，可以证明我们的消息持久化策略也已经生效。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。4、小结当RabbitMQ服务器重启后，原先的队列和交换器会随同里面的消息一同消失。原因在于每个队列和交换器都有durable属性，该属性默认是false，它决定了RabbitMQ是否需要在崩溃或者重启之后重新创建队列或者交换器。将它设置为true就代表了持久性，在服务器重启之后就会重新持久的创建队列和交换器。当然做到这点还不够，我们需要的是持久化的消息，所以在消息发布前，通过将消息的“投递模式”(delivery mode)属性设置为2将消息标记为持久化。到目前为止，消息还只是被表示为持久化，还需要被发布到持久化的交换器中并到达持久化的队列中才行。如果不是这样，包含持久化消息的队列或者交换器挥着Rabbit崩溃重启后不复存在，导致消息成为一个孤儿。因此，总结起来需要做到以下三点：将消息的投递模式选项设置为2(持久)；将消息发送到持久化的交换器；消息到达持久化的队列。注意，如果原先有非持久的交换器或者队列，需要删除后才可重新创建，否则就创建其他名称的交换器或者队列。十二、RabbitMQ –消息确认机制正常情况下，如果消息经过交换器进入队列就可以完成消息的持久化，但如果消息在没有到达RabbitMQ服务器Broker之前出现意外，那就造成消息丢失，有没有办法可以解决这个问题？RabbitMQ有两种方式来解决这个问题：通过AMQP提供的事务机制实现；使用发送者确认模式实现；1、事务机制事务的实现主要是对信道（Channel）的设置，主要的方法有三个：channel.txSelect() 声明启动事务模式；channel.txComment() 提交事务；channel.txRollback() 回滚事务；发送者使用事务创建消息发送者代码：Send.java1234567891011121314151617181920212223242526272829303132333435import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class Send &#123; private static final String QUEUE_NAME = "transaction_queue"; public static void main(String[] args) throws IOException, TimeoutException &#123; Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = "transaction_test"; try &#123; //1、声明事务 channel.txSelect(); channel.basicPublish("", QUEUE_NAME, null, message.getBytes("utf-8")); System.out.println(" [x] Sent '" + message + "'"); //除以0，模拟异常，使用rabbitmq默认交换机 int i = 1/0; //2、提交事务 channel.txCommit(); &#125; catch (Exception e) &#123; //3、回滚事务 channel.txRollback(); System.out.println("回滚事务：" + e.getMessage()); &#125; finally &#123; channel.close(); connection.close(); &#125; &#125;&#125;从上面的代码我们可以看出，在发送消息之前的代码和之前介绍的都是一样的，只是在发送消息之前，需要声明channel为事务模式，提交或者回滚事务即可。消费者使用事务假设消费者模式中使用了事务，并且在消息确认之后进行了事务回滚，那么RabbitMQ会产生什么样的变化？结果分为两种情况：autoAck=false手动应对的时候是支持事务的，也就是说即使你已经手动确认了消息已经收到了，但在确认消息会等事务的返回解决之后，在做决定是确认消息还是重新放回队列，如果你手动确认现在之后，又回滚了事务，那么已事务回滚为主，此条消息会重新放回队列；autoAck=true如果自定确认为true的情况是不支持事务的，也就是说你即使在收到消息之后在回滚事务也是于事无补的，队列已经把消息移除了；小结事务模式的性能很差，那有没有既能保证消息的可靠性又能兼顾性能的解决方案呢？那就是接下来要讲的Confirm发送方确认模式。2、Confirm发送方确认模式Confirm发送方确认模式使用和事务类似，也是通过设置Channel进行发送方确认的。Confirm的三种实现方式：channel.waitForConfirms() 普通发送方确认模式；channel.waitForConfirmsOrDie() 批量确认模式；channel.addConfirmListener() 异步监听发送方确认模式；方式一：普通Confirm模式：SendConfirm.java12345678910111213141516171819202122232425262728import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class SendConfirm &#123; private static final String QUEUE_NAME = "confirm_queue"; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123; Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = " confirm_test"; //开启发送方确认模式 channel.confirmSelect(); channel.basicPublish("", QUEUE_NAME, null, message.getBytes("utf-8")); System.out.println(" [x] Sent '" + message + "'"); if (channel.waitForConfirms()) &#123; System.out.println("消息发送成功" ); &#125; channel.close(); connection.close(); &#125;&#125;看代码可以知道，我们只需要在推送消息之前，channel.confirmSelect()声明开启发送方确认模式，再使用channel.waitForConfirms()等待消息被服务器确认即可。方式二：批量Confirm模式：SendBatchConfirm.java12345678910111213141516171819202122232425262728293031import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class SendBatchConfirm &#123; private static final String QUEUE_NAME = "confirm_queue"; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123; Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = " confirm_test"; //开启发送方确认模式 channel.confirmSelect(); for (int i = 0; i &lt; 10; i++) &#123; channel.basicPublish("", QUEUE_NAME, null, message.getBytes("utf-8")); System.out.println(" [x] Sent '" + message + "' - " + i); &#125; //直到所有信息都发布，只要有一个未确认就会IOException channel.waitForConfirmsOrDie(); System.out.println("消息发送成功"); channel.close(); connection.close(); &#125;&#125;以上代码可以看出来channel.waitForConfirmsOrDie()，使用同步方式等所有的消息发送之后才会执行后面代码，只要有一个消息未被确认就会抛出IOException异常。方式三：异步Confirm模式：SendAsynConfirm.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.IOException;import java.util.concurrent.TimeoutException;import com.rabbitmq.client.Channel;import com.rabbitmq.client.ConfirmListener;import com.rabbitmq.client.Connection;import cn.dj.rabbitmq.util.ConnectionUtils;public class SendAsynConfirm &#123; private static final String QUEUE_NAME = "confirm_queue"; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123; Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); //开启发送方确认模式 channel.confirmSelect(); //异步监听确认和未确认的消息 channel.addConfirmListener(new ConfirmListener() &#123; @Override public void handleNack(long deliveryTag, boolean multiple) throws IOException &#123; System.out.println("未确认消息，标识：" + deliveryTag); &#125; @Override public void handleAck(long deliveryTag, boolean multiple) throws IOException &#123; try &#123; //这里设置秒延迟，便于观察 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(String.format("已确认消息，标识：%d，多个消息：%b", deliveryTag, multiple)); &#125; &#125;); String message = "confirm_test"; for (int i = 0; i &lt; 5; i++) &#123; channel.basicPublish("", QUEUE_NAME, null, message.getBytes("utf-8")); System.out.println(" [x] Sent '" + message + "' - " + i); &#125; System.out.println("程序执行结束"); channel.close(); connection.close(); &#125;&#125;异步模式的优点，就是执行效率高，不需要等待消息执行完，只需要监听消息即可，以上异步返回的信息如下：1234567 [x] Sent &apos;confirm_test&apos; - 0 [x] Sent &apos;confirm_test&apos; - 1 [x] Sent &apos;confirm_test&apos; - 2 [x] Sent &apos;confirm_test&apos; - 3 [x] Sent &apos;confirm_test&apos; - 4程序执行结束已确认消息，标识：1，多个消息：false十三、RabbitMQ – Spring集成-XML版本1、新建Maven项目，修改pom.xml123456789101112131415161718192021222324252627282930313233343536373839&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.dj&lt;/groupId&gt; &lt;artifactId&gt;rabbitmq-spring-xml&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;rabbitmq-spring-xml&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;jdk.version&gt;1.8&lt;/jdk.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt; &lt;version&gt;1.7.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;rabbitmq-spring-xml&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;$&#123;jdk.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;jdk.version&#125;&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;2、新建spring-rabbitmq.xml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:rabbit="http://www.springframework.org/schema/rabbit" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.7.xsd"&gt; &lt;!-- 1、配置Rabbit连接工厂 --&gt; &lt;rabbit:connection-factory id="connectionFactory" host="127.0.0.1" port="5672" virtual-host="/virtual_test" username="djtest" password="djtest" /&gt; &lt;!-- 2、创建Rabbit消息队列模版 --&gt; &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="fanoutExchange" /&gt; &lt;!-- 3、MQ的管理，包括队列、交换机等 --&gt; &lt;rabbit:admin connection-factory="connectionFactory" /&gt; &lt;!-- 4、定义队列，自动声明 --&gt; &lt;rabbit:queue name="spring_rabbit_queue" auto-declare="true" durable="true" /&gt; &lt;!-- 5、定义交换机，自动声明 --&gt; &lt;rabbit:fanout-exchange id="fanoutExchange" name="fanoutExchange" auto-declare="true"&gt; &lt;!-- 6、绑定队列 --&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="spring_rabbit_queue" /&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:fanout-exchange&gt; &lt;!-- 7、队列监听 --&gt; &lt;rabbit:listener-container connection-factory="connectionFactory"&gt; &lt;rabbit:listener ref="testConsumer1" method="listen" queue-names="spring_rabbit_queue" /&gt; &lt;!-- &lt;rabbit:listener ref="testConsumer2" queue-names="spring_rabbit_queue" /&gt; --&gt; &lt;/rabbit:listener-container&gt; &lt;!-- 8、消费者 消费者1：采用指定监听方法的方式 消费者2：采用实现接口的方式、无需指定方法 --&gt; &lt;bean id="testConsumer1" class="cn.dj.rabbit.consumer.TestConsumer1"&gt;&lt;/bean&gt; &lt;!-- &lt;bean id="testConsumer2" class="cn.dj.rabbit.consumer.TestConsumer2"&gt;&lt;/bean&gt; --&gt;&lt;/beans&gt;3、新建消费者TestConsumer1.java（指定方法方式）123456public class TestConsumer1 &#123; //监听方法 public void listen(String msg) &#123; System.out.println("收到消息===&gt;" + msg); &#125;&#125;TestConsumer2.java（实现接口方式）12345678910public class TestConsumer2 implements MessageListener &#123; @Override public void onMessage(Message msg) &#123; try &#123; System.out.println("收到消息===&gt;" + new String(msg.getBody(), "utf-8")); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125;&#125;4、新建启动类：SpringMain.java123456789101112import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringMain &#123; public static void main(String[] args) throws InterruptedException &#123; AbstractApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring-rabbitmq.xml"); RabbitTemplate template = context.getBean(RabbitTemplate.class); template.convertAndSend("hello spring-rabbit"); context.destroy(); &#125;&#125;5、测试结果6、注意以上消费者代码实现方式在spring-rabbit 2.0.0.RELEASE及以上版本启动会报错，具体原因尚未查明。十四、RabbitMQ - Spring集成-注解版本敬请期待十五、RabbitMQ - SpringBoot集成敬请期待总结关于 RabbitMQ 的五种队列，其实实际使用最多的是最后一种主题模式，通过模糊匹配，使得操作更加自如。那么我们总结一下有交换器参与的队列（最后三种队列）工作方式如下：代码下载基础示例代码RabbitMQ与Spring集成XML版本代码]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一十一章：SpringBoot整合其他服务]]></title>
    <url>%2F2017-02-25%2F%E7%AC%AC%E4%B8%80%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9ASpringBoot%E6%95%B4%E5%90%88%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1.html</url>
    <content type="text"><![CDATA[在进行项目开发的时候经常遇见以下的几个问题：需要进行邮件发送、定时任务调度、系统的监控处理，实际上这些操作都可以通过SpringBoot进行整合操作。一、邮件服务如果要进行邮件的整合处理，一定需要一个邮件服务器，实际上java本身提供有一套JavaMail主键以实现邮件服务器的搭建，但是这个搭建的服务器意义不大，你因为现在搭建完成了，向一些大型的站点发送一封右键，若干小时你就会被拉黑，如果不想拉黑彼此之间就做一个白名单即可。那么如果现在自己搭建右键服务器不行，就可以考虑使用QQ邮件服务器、网易右键服务，本次可以申请一个QQ邮箱服务器，如果要申请你一定要登录你自己的QQ邮箱。1、如果要想实现邮件的发送服务，则首先要导入一个依赖的支持库：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;2、修改项目中的application.yml配置文件，实现邮件的配置：1234567891011server: port: 80spring: mail: host: smtp.qq.com username: xxxxxxxx@qq.com password: kppavkgkrwnhbjbg properties: main.smtp.auth: true mail.smtp.strttls.enable: true mail.smtp.strttls.required: true3、编写测试类，直接编写mail服务：1234567891011121314151617181920212223242526272829303132333435package com.example.test;import java.sql.SQLException;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import com.example.microboot.StartSpringBootMain;@SpringBootTest(classes = StartSpringBootMain.class)@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfigurationpublic class TestMail &#123; @Resource private JavaMailSender javaMailSender; @Test public void testSendMail() throws SQLException &#123; // 要发送的消息内容 SimpleMailMessage message = new SimpleMailMessage(); message.setFrom("发送邮件的帐号：send@qq.com"); message.setTo("接收邮件的帐号：receive@qq.com"); message.setSubject("测试邮件（来自老李的祝福）"); message.setText("好好学习，天天向上"); this.javaMailSender.send(message); &#125;&#125;二、定时任务调度现在绝大部分系统开发之中个都会涉及到定时调度的话题，对于定时调度的实际开发之中可以使用：TimerTask、Quartz、SpringTask配置，这里面最简单的配置就是Spring自己所提供的Task处理。1、如果要实现定时调度，只需要配置一个定时调度的主键类即可：1234567891011121314151617181920212223package com.example.microboot.task;import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class MyScheduler &#123; // 采用间隔调度，每2秒执行一次 @Scheduled(fixedRate = 2000) public void runJobA() &#123; System.out.println("MyTaskA --- 间隔：" + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(new Date())); &#125; // 每秒执行一次 @Scheduled(cron = "* * * * * ?") public void runJoB() &#123; System.err.println("MyTaskB --- 间隔：" + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(new Date())); &#125;&#125;2、如果现在要想执行此任务，那么还需要一个基本的前提：你的程序启东类上一定要启用调度处理：1234567891011121314package com.example.microboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableSchedulingpublic class StartSpringBootMain &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(StartSpringBootMain.class, args); &#125;&#125;这个时候所实现的任务调度只是串行任务调度，也就是说所有的任务是一个一个执行的，那么如果现在有一个任务所话费的时间特别的长，则其他的任务都会排队等待，实际开发中这种方式明显不符合我们的需求。3、如果想要启用冰心的调度处理，则一定要准备出一个线程调度池，现在写一个线程调度的配置类：1234567891011121314151617package com.example.microboot.config;import java.util.concurrent.Executors;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.SchedulingConfigurer;import org.springframework.scheduling.config.ScheduledTaskRegistrar;@Configuration // 定时调度的配置类一定要实现指定的父接口public class SchedulerConfig implements SchedulingConfigurer &#123; @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; // 开启一个线程调度池 taskRegistrar.setScheduler(Executors.newScheduledThreadPool(100)); &#125;&#125;在以后所编写的定时任务调度的时候一定要准备好一个线程池，这样才能够让多个任务并行执行。三、Actuator监控对于SpringBoot中服务的监控在SpringBoot开发框架之中提供有一个Actuator监控程序，但是这个监控在很多时候的使用有一些矛盾，对于此类的信息服务，一般而言会有两类信息：第一类是由系统直接提供的信息，这个需要关闭安全控制；第二类是由用户定义的，希望可以返回固定的一些信息，例如：版本、服务名称等。1、如果现在要想在代码中启动Actuator服务，那么首先一定要进行开发包的配置：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;2、此时配置此依赖包的项目就具有了监控的能力，但是这个能力无法直接体现，如果现在要想打开默认的系统的这些监控信息，则需要修改application.yml配置文件，关闭掉当前的安全配置项：12345server: port: 80management: security: enabled: false # 现在关闭系统的安全配置3、但是如果现在将系统的安全配置关闭之后，此时你的系统的服务信息就有可能被任何人看见，那么不希望被所有人看见，但是又希望所有人可以看见一部分的提示信息，所以在这样的状态下，就需要去考虑自定义一些服务信息，例如，现在先进行健康信息的配置：范例：定义一个健康配置类：12345678910111213package com.example.microboot.actuator;import org.springframework.boot.actuate.health.Health;import org.springframework.boot.actuate.health.HealthIndicator;import org.springframework.stereotype.Component;@Componentpublic class MyHealthIndicator implements HealthIndicator &#123; @Override public Health health() &#123; return Health.up().withDetail("info", "Hello World!!!").build(); &#125;&#125;但是发现这种健康的信息配置是需要关闭安全策略之后才能够发现更加详细的内容，而如果开启了安全策略之后可以看到的信息只能够是一些基础的状态：UP（存活）、DOWN（关闭）。123456789101112131415161718package com.example.microboot.actuator;import org.springframework.boot.actuate.health.Health;import org.springframework.boot.actuate.health.HealthIndicator;import org.springframework.stereotype.Component;@Componentpublic class MyHealthIndicator implements HealthIndicator &#123; @Override public Health health() &#123; int errorCode = 100; // 这个错误码是通过其他程序获得的 if (errorCode != 0) &#123; return Health.down().withDetail("Error Code", errorCode).build(); &#125; return Health.up().build(); &#125;&#125;4、除了健康之外，还有一巷数据很重要，就是一些服务的信息（“/info”）.而这些服务的信息可以直接通过application.yml文件配置，修改application.yml要按照指定的格式完成：对于这样的配置信息最好的方式就是进行pom.xml文件的读取，所以如果要想实现这种关联操作必须修改microboot项目中的pom.xml文件，追加有一个访问的插件：1234567891011121314151617181920&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;delimiters&gt; &lt;delimiter&gt;$&lt;/delimiter&gt; &lt;/delimiters&gt; &lt;/configuration&gt;&lt;/plugin&gt;&lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.yml&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.tld&lt;/include&gt; &lt;include&gt;**/*.p12&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt;&lt;/resource&gt;修改application.yml配置文件，追加详细信息：1234567891011server: port: 80management: security: enabled: trueinfo: app.name: actuator-microboot app.version: v1.0.0 company.name: www.xxx.cn pom.artifactId: $project.artifactId$ pom.version: $project.version$5、由于在开发之中这种提示信息会成为为服务的重要组成部分，所以很多时候重复进行配置文件的定义，那么会比较麻烦，最贱的做法直接做一个配置程序类进行信息的配置：123456789101112131415package com.example.microboot.config;import org.springframework.boot.actuate.info.Info.Builder;import org.springframework.boot.actuate.info.InfoContributor;import org.springframework.stereotype.Component;@Componentpublic class ProjectInfoContributor implements InfoContributor &#123; @Override public void contribute(Builder builder) &#123; builder.withDetail("company.name", "www.xxx.cn"); builder.withDetail("version", "v1.0.0"); builder.withDetail("author", "Tom"); &#125;&#125;以后在实际的开发之中，为了不重复编写一些配置信息，往往会将配置信息放在统一的一个模块里面，需要的时候进行互相引用即可。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十章：SpringBoot整合消息服务]]></title>
    <url>%2F2017-02-19%2F%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9ASpringBoot%E6%95%B4%E5%90%88%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1.html</url>
    <content type="text"><![CDATA[对于异步消息组件在实际的应用之中会有两类：JMS：代表作就是ActiveMQ，但是其性能不高，因为其是用java程序实现的；AMQB：直接利用协议实现的消息组件，其广谱代表作：RabbitMQ，高性能代表作：Kafka。一、整合ActiveMQ组件1、如果要想在项目中使用ActiveMQ组件，则应该为项目添加依赖支持库，修改pom.xml配置文件：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt;2、修改application.yml配置文件进行activemq的配置：1234567spring: jms: pub-sub-domain: false #配置消息的类型，如果是true则表示为topic消息，如果为false则是Queue消息 activemq: user: activemq #连接用户名 password: hello #连接密码 broker-url: tcp://activemq-server:61616 #消息组件的连接主机信息3、随后定义一个消息的消费者，消费者主要进行一个监听控制，在SpringBoot里面可以直接利用注解进行监听：12345678910111213package com.example.microboot.consumer;import org.springframework.jms.annotation.JmsListener;import org.springframework.stereotype.Service;@Servicepublic class MessageConsumerService &#123; // 进行消息接收处理 @JmsListener(destination = "activemq.msg.queue") public void receiveMessage(String text) &#123; System.err.println("【*** 接收消息 ***】" + text); &#125;&#125;4、随后建立消息的发送则服务，一般而言如果进行消息的发送往往会准备出一个业务接口来：12345package com.example.microboot.producer;public interface IMessageProducerService &#123; public void sendMessage(String msg);&#125;5、随后建立一个配置程序类，定义ActiveMQ的消息发送模版处理类：123456789101112131415161718package com.example.microboot.config;import javax.jms.Queue;import org.apache.activemq.command.ActiveMQQueue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jms.annotation.EnableJms;@Configuration@EnableJmspublic class ActiveMQConfig &#123; @Bean public Queue queue() &#123; return new ActiveMQQueue("activemq.msg.queue"); &#125;&#125;6、创建消息发送的子类，实现消息的处理：123456789101112131415161718192021package com.example.microboot.producer.impl;import javax.annotation.Resource;import javax.jms.Queue;import org.springframework.jms.core.JmsMessagingTemplate;import org.springframework.stereotype.Service;import com.example.microboot.producer.IMessageProducerService;@Servicepublic class MessageProducerServiceImpl implements IMessageProducerService &#123; @Resource private JmsMessagingTemplate jmsMessagingTemplate; @Resource private Queue queue; @Override public void sendMessage(String msg) &#123; this.jmsMessagingTemplate.convertAndSend(this.queue, msg); &#125;&#125;7、编写测试类来观察消息的处理：123456789101112131415161718192021222324252627package com.example.test;import java.sql.SQLException;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import com.example.microboot.StartSpringBootMain;import com.example.microboot.producer.IMessageProducerService;@SpringBootTest(classes = StartSpringBootMain.class)@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfigurationpublic class TestActiveMQ &#123; @Resource private IMessageProducerService messageProducer; @Test public void testSend() throws SQLException &#123; for (int i = 0; i &lt; 100; i++) &#123; this.messageProducer.sendMessage("hello world: " + i); &#125; &#125;&#125;基于SpringBoot配置的JMS的组件访问整体的处理十分简单。二、整合RabbitMQ组件如果要进行RabbitMQ整合的时候一定要注意以下几个概念：交换空间、虚拟主机、队列信息。本次为了方便起见，将项目分为两个：RabbitMQ-Consumer、RabbitMQ-Producer。1、【两个项目】将rabbitmq的依赖支持包拷贝到项目之中；1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;2、【microboot-rabbitmq-producer、microboot-rabbitmq-consumer】修改application.yml配置文件，追加rabbitmq的相关配置项：12345678server: port: 80spring: rabbitmq: addresses: rabbitmq-server username: rabbitmq password: hello virtual-host: /3、【microboot-rabbitmq-producer】建立一个消息的发送接口：12345package com.example.microboot.producer;public interface IMessageProducerService &#123; public void sendMessage(String msg);&#125;4、【microboot-rabbitmq-producer】为了可以正常使用RabbitMQ进行消息处理，还需要做一个消息生产配置类；1234567891011121314151617181920212223242526272829303132package com.example.microboot.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class ProducerConfig &#123; // 交换空间名称 public static final String EXCHANGE = "rabbitmq.microboot.exchange"; // 设置路由key public static final String ROUTINGKEY = "rabbitmq.microboot.routingkey"; // 队列名称 public static final String QUEUE_NAME = "rabbitmq.microboot.queue"; @Bean public Binding bindingExchangeQueue(DirectExchange exchange, Queue queue) &#123; return BindingBuilder.bind(queue).to(exchange).with(ROUTINGKEY); &#125; // 使用直连的模式 @Bean public DirectExchange getDirectExchage() &#123; return new DirectExchange(EXCHANGE, true, true); &#125; // 要创建的队列信息 @Bean public Queue queue() &#123; return new Queue(QUEUE_NAME); &#125;&#125;5、【microboot-rabbitmq-producer】创建消息服务的实现子类：12345678910111213141516171819package com.example.microboot.producer.impl;import javax.annotation.Resource;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.stereotype.Service;import com.example.microboot.config.ProducerConfig;import com.example.microboot.producer.IMessageProducerService;@Servicepublic class MessageProducerServiceImpl implements IMessageProducerService &#123; @Resource private RabbitTemplate rabbitTemplate; @Override public void sendMessage(String msg) &#123; this.rabbitTemplate.convertAndSend(ProducerConfig.EXCHANGE, ProducerConfig.ROUTINGKEY, msg); &#125;&#125;6、【microboot-rabbitmq-consumer】依然需要做一个消费者的配置程序类，而这个程序类里面主要的目的依然是设置交换空间、路由KEY等信息：1234567891011121314151617181920212223242526272829303132package com.example.microboot.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class ConsumerConfig &#123; // 交换空间名称 public static final String EXCHANGE = "rabbitmq.microboot.exchange"; // 设置路由key public static final String ROUTINGKEY = "rabbitmq.microboot.routingkey"; // 队列名称 public static final String QUEUE_NAME = "rabbitmq.microboot.queue"; @Bean public Binding bindingExchangeQueue(DirectExchange exchange, Queue queue) &#123; return BindingBuilder.bind(queue).to(exchange).with(ROUTINGKEY); &#125; // 使用直连的模式 @Bean public DirectExchange getDirectExchage() &#123; return new DirectExchange(EXCHANGE, true, true); &#125; // 要创建的队列信息 @Bean public Queue queue() &#123; return new Queue(QUEUE_NAME); &#125;&#125;7、【microboot-rabbitmq-consumer】实现监听处理类：12345678910111213package com.example.microboot.consumer;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Service;@Servicepublic class MessageConsumerService &#123; // 进行消息接收处理 @RabbitListener(queues = "rabbitmq.microboot.queue") public void receiveMessage(String text) &#123; System.err.println("【*** 接收消息 ***】" + text); &#125;&#125;8、【microboot-rabbitmq-producer】创建一个测试类实现消息的发送处理：12345678910111213141516171819202122232425262728package com.example.test;import java.sql.SQLException;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import com.example.microboot.StartSpringBootMain;import com.example.microboot.producer.IMessageProducerService;@SpringBootTest(classes = StartSpringBootMain.class)@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfigurationpublic class TestRabbitMQ &#123; @Resource private IMessageProducerService messageProducer; @Test public void testSend() throws SQLException &#123; for (int i = 0; i &lt; 100; i++) &#123; this.messageProducer.sendMessage("hello world: " + i); &#125; &#125;&#125;9、【microboot-rabbitmq-consumer】编写消息接收测试类，这里面不需要写代码，只需要做一个休眠即可：1234567891011121314151617181920package com.example.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import com.example.microboot.StartSpringBootMain;@SpringBootTest(classes = StartSpringBootMain.class)@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfigurationpublic class TestRabbitMQ &#123; @Test public void testStart() throws InterruptedException &#123; Thread.sleep(Long.MAX_VALUE); &#125;&#125;整体进行项目开发之中整合的步骤还是简单，但是要注意，将生产者与消费者的配置类分开了，实际上这两个类的作用是一样的。三、整合Kafka组件Kafka是现在最好的开源消息组件，其仿照AMQP协议操作，而且处理的性能也是最高的。本次使用已经配置好的Kafka服务器，而且这台服务器使用了kerberos认证，所以首先应该准备好一个jass配置文件：1、定义kafka_client_jaas.conf配置文件：12345KafkaClient &#123; org.apache.kafka.common.security.plain.PlainLoginModule required usename=&quot;bob&quot; password=&quot;bob-pwd&quot;;&#125;;2、为了方便进行项目的观察，本次依然准备出两个项目：生产者（microboot-kafka-producer）、消费者（microboot-kafka-consumer），随后为这两个项目添加Kafka配置支持：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;3、【microboot-kafka-consumer】修改application.yml配置文件，进行kafka配置项编写：123456789101112131415server: port: 80spring: kafka: bootstrap-servers: - kafka-single:9095 template: default-topic: kafka-microboot consumer: key-deserializer: org.apache.kafka.common.serialization.StringDeserializer value-deserializer: org.apache.kafka.common.serialization.StringDeserializer group-id: group-1 properties: sasl.mechanism: PLAIN security.protocol: SASL_PLAINTEXT4、【microboot-kafka-consumer】建立一个kafka的消费程序类：123456789101112131415package com.example.microboot.consumer;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.springframework.kafka.annotation.KafkaListener;import org.springframework.stereotype.Service;@Servicepublic class MessageConsumerService &#123; @KafkaListener(topics = &#123; "kafka-microboot" &#125;) public void receiveMessage(ConsumerRecord&lt;String, String&gt; record) &#123; System.err.println("【*** 接收消息 ***】key = " + record.key() + "、value = " + record.value()); &#125;&#125;5、【microboot-kafka-consumer】随后还需要修改SpringBoot的启动程序类，追加kerberos配置：123456789101112131415package com.example.microboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class StartSpringBootMain &#123; static &#123; // 表示系统环境属性 System.setProperty("java.security.auth.login.config", "D:/kafka_client_jaas.conf"); &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(StartSpringBootMain.class, args); &#125;&#125;6、【microboot-kafka-producer】修改application.yml配置文件：1234567891011121314server: port: 80spring: kafka: bootstrap-servers: - kafka-single:9095 template: default-topic: kafka-microboot producer: key-serializer: org.apache.kafka.common.serialization.StringSerializer value-serializer: org.apache.kafka.common.serialization.StringSerializer properties: sasl.mechanism: PLAIN security.protocol: SASL_PLAINTEXT7、【microboot-kafka-producer】定义消息发送的服务接口：12345package com.example.microboot.producer;public interface IMessageProducerService &#123; public void sendMessage(String msg);&#125;123456789101112131415161718package com.example.microboot.producer.impl;import javax.annotation.Resource;import org.springframework.kafka.core.KafkaTemplate;import org.springframework.stereotype.Service;import com.example.microboot.producer.IMessageProducerService;@Servicepublic class MessageProducerServiceImpl implements IMessageProducerService &#123; @Resource private KafkaTemplate&lt;String, String&gt; kafkaTemplate; @Override public void sendMessage(String msg) &#123; this.kafkaTemplate.sendDefault("kafka-key", msg); &#125;&#125;8、【microboot-kafka-producer】修改程序启动类：123456789101112131415package com.example.microboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class StartSpringBootMain &#123; static &#123; // 表示系统环境属性 System.setProperty("java.security.auth.login.config", "D:/kafka_client_jaas.conf"); &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(StartSpringBootMain.class, args); &#125;&#125;9、编写消息发送的测试类：microboot-kafka-producer12345678910111213141516171819202122232425262728package com.example.test;import java.sql.SQLException;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import com.example.microboot.StartSpringBootMain;import com.example.microboot.producer.IMessageProducerService;@SpringBootTest(classes = StartSpringBootMain.class)@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfigurationpublic class TestKafka &#123; @Resource private IMessageProducerService messageProducer; @Test public void testSend() throws SQLException &#123; for (int i = 0; i &lt; 100; i++) &#123; this.messageProducer.sendMessage("hello world: " + i); &#125; &#125;&#125;microboot-kafka-consumer1234567891011121314151617181920package com.example.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import com.example.microboot.StartSpringBootMain;@SpringBootTest(classes = StartSpringBootMain.class)@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfigurationpublic class TestKafka &#123; @Test public void testStart() throws InterruptedException &#123; Thread.sleep(Long.MAX_VALUE); &#125;&#125;在使用Kafka进行数据处理的时候，它速度快的主要原因是采用的协议、处理的模式、零拷贝。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九章：SpringBoot整合MyBatis]]></title>
    <url>%2F2017-01-22%2F%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9ASpringBoot%E6%95%B4%E5%90%88MyBatis.html</url>
    <content type="text"><![CDATA[SpringBoot得到的最终效果是一个简化到极致的WEB开发，但是只要牵扯到WEB开发，就绝对不可能缺少数据层操作，所有的开发都一定秉持着MVC设计模式的原子，MVC里面业务层不可少，数据层永远要与业务层绑定在一起，既然要进行数据层的操作，那么肯定首选的一定就是MyBatis，因为Mybatis整合处理之后尤其是与Spring整合里面可以直接避免掉DAO层的编写，同时VO类也是最干净的，这一点上绝对比其他的ORMapping组件更方便。一、配置druid数据库连接池这个数据库连接池的配置是由阿里提供的，并且由于性能很高，同时具备有很好的监控性，在实际的开发之中已经开始广泛的使用了。1、 首先编写一个数据库创建脚本：12345678910111213DROP database IF EXISTS springboot;CREATE DATABASE springboot CHARACTER SET UTF8;USE springboot;CREATE TABLE dept ( deptno BIGINT AUTO_INCREMENT, dname VARCHAR(50), CONSTRAINT pk_deptno PRIMARY KEY(deptno));INSERT INTO dept(dname) VALUE ('开发部');INSERT INTO dept(dname) VALUE ('财务部');INSERT INTO dept(dname) VALUE ('市场部');INSERT INTO dept(dname) VALUE ('人事部');INSERT INTO dept(dname) VALUE ('公关部');2、 随后要进行druid的数据源的配置，如果要想使用druid的数据源，那么首先一定要修改pom.xml配置文件，引入以下包12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.5&lt;/version&gt;&lt;/dependency&gt;3、 如果要进行数据源的整合处理，直接修改application.yml配置文件即可：1234567891011121314server: port: 80spring: datasource: type: com.alibaba.druid.pool.DruidDataSource # 配置当前要使用的数据源的操作类型 driver-class-name: com.mysql.jdbc.Driver # 配置Mysql的驱动程序类 url: jdbc:mysql://localhost:3306/springboot # 数据库连接地址 username: root # 数据库用户名 password: admin # 数据库密码 dbcp2: # 进行数据库连接池的配置 min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化提供的连接数 max-total: 5 # 最大的连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间4、如果这个时候要进行junit代码测试，则一定要将Mybatis开发包配置过来，因为只有在Mybatis开发包里面才会将druid的配置的数据库连接池变为所需要的DataSource数据源对象。12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;5、测试一下当前的连接池是否可用：12345678910111213141516171819202122232425262728package com.example.test;import java.sql.SQLException;import javax.annotation.Resource;import javax.sql.DataSource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import com.example.microboot.StartSpringBootMain;@SpringBootTest(classes = StartSpringBootMain.class)@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfigurationpublic class TestDataSource &#123; @Resource private DataSource dataSource; @Test public void testConnection() throws SQLException &#123; System.out.println(this.dataSource.getConnection()); &#125;&#125;此时可以获取数据库连接，表示当前的druid的配置正确。二、整合Mybatis开发框架如果要进行mybatis的配置一定要导入spring-boot所支持的mybatis开发包。12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;1、修改application.yml配置文件，最佳mybatis的相关配置项：12345mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路劲 type-aliases-package: com.example.microboot.vo # 定义所有操作类的别名所在包 mapper-locations: # 所有的mapper映射文件 - classpath:mybatis/mapper/**/*.xml2、建立一个Dept的VO类；1234567891011121314151617181920212223242526272829303132package com.example.microboot.vo;import java.io.Serializable;@SuppressWarnings("serial")public class Dept implements Serializable &#123; private Long deptno; private String dname; public Long getDeptno() &#123; return deptno; &#125; public void setDeptno(Long deptno) &#123; this.deptno = deptno; &#125; public String getDname() &#123; return dname; &#125; public void setDname(String dname) &#123; this.dname = dname; &#125; @Override public String toString() &#123; return "Dept [deptno=" + deptno + ", dname=" + dname + "]"; &#125;&#125;3、在src/main/resources目录下建立一个mybatis.cfg.xml配置文件：12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;/settings&gt;&lt;/configuration&gt;4、 src/main/resources/mybatis下建立一个mapper子目录，而后在里面定义有Dept.xml映射文件12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace=""&gt; &lt;select id="list" resultType="com.example.microboot.dao.IDeptDAO"&gt; select deptno, dname from dept &lt;/select&gt;&lt;/mapper&gt;5、建立IDeptDAO接口；123456789101112package com.example.microboot.dao;import java.util.List;import org.apache.ibatis.annotations.Mapper;import com.example.microboot.vo.Dept;@Mapperpublic interface IDeptDAO &#123; List&lt;Dept&gt; list();&#125;在定义DAO接口的时候由于需要自动生成实现子类，所以在接口声明处一定要加上一个@Mapper的注解，否者DAO接口和*.xml的Mapper文件无法整合在一起。6、建立一个IDeptService接口，作为服务使用：12345678package com.example.microboot.service;import java.util.List;import com.example.microboot.vo.Dept;public interface IDeptService &#123; List&lt;Dept&gt; list();&#125;1234567891011121314151617181920212223package com.example.microboot.service.impl;import java.util.List;import javax.annotation.Resource;import org.springframework.stereotype.Service;import com.example.microboot.dao.IDeptDAO;import com.example.microboot.service.IDeptService;import com.example.microboot.vo.Dept;@Servicepublic class DeptService implements IDeptService &#123; @Resource private IDeptDAO deptDAO; @Override public List&lt;Dept&gt; list() &#123; return this.deptDAO.list(); &#125;&#125;7、进行代码测试类编写：1234567891011121314151617181920212223242526272829package com.example.test;import java.sql.SQLException;import java.util.List;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import com.example.microboot.StartSpringBootMain;import com.example.microboot.service.IDeptService;import com.example.microboot.vo.Dept;@SpringBootTest(classes = StartSpringBootMain.class)@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfigurationpublic class TestDeptService &#123; @Resource private IDeptService deptService; @Test public void testList() throws SQLException &#123; List&lt;Dept&gt; list = deptService.list(); for (Dept dept : list) &#123; System.out.println(dept.toString()); &#125; &#125;&#125;此时测试通过，则SpringBoot与MyBatis已近可以成功的整合再一起进行项目开发，此时的配置要比之前使用Spring+MyBatis直接配置简单很多。三、事务控制在Spring之中提供的事务控制里面有以下的几种数据级别。如果现在要想在SpringBoot里面去启用MyBatis事务（数据库的事务），那么就可以通过如下的方式来完成。1、修改IDeptService接口，追加一个只读事务控制；12345678910package com.example.microboot.service;import java.util.List;import org.springframework.transaction.annotation.Transactional;import com.example.microboot.vo.Dept;public interface IDeptService &#123; @Transactional(readOnly = true) List&lt;Dept&gt; list();&#125;此时配置了一个只读的事务操作，那么也就是说在这个业务方法只能采用读的模式来进行操作。2、但是现在配置了一个注解并不表示当前已经合理的支持了事务，如果要进行事务的启用，还需要在程序的启动类上追加一个新的注解配置：12345678910111213package com.example.microboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.transaction.annotation.EnableTransactionManagement;@SpringBootApplication // 启动SpringBoot程序,而后自带子包扫描@EnableTransactionManagementpublic class StartSpringBootMain &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(StartSpringBootMain.class, args); &#125;&#125;3、 如果现在要想更好的观察事务的问题，最简单的做法是编写一个数据增加操作，而后为这个业务方法设置只读配置。追加一个新的方法：com.example.microboot.dao.IDeptDAO1234567891011package com.example.microboot.dao;import java.util.List;import org.apache.ibatis.annotations.Mapper;import com.example.microboot.vo.Dept;@Mapperpublic interface IDeptDAO &#123; List&lt;Dept&gt; list(); boolean add(Dept dept);&#125;com.example.microboot.service.IDeptService12345678910111213package com.example.microboot.service;import java.util.List;import org.springframework.transaction.annotation.Transactional;import com.example.microboot.vo.Dept;public interface IDeptService &#123; @Transactional(readOnly = true) List&lt;Dept&gt; list(); // 暂时设置为只读事务 @Transactional(readOnly = true) boolean add(Dept dept);&#125;com.example.microboot.service.impl.DeptService123456789101112131415161718192021222324package com.example.microboot.service.impl;import java.util.List;import javax.annotation.Resource;import org.springframework.stereotype.Service;import com.example.microboot.dao.IDeptDAO;import com.example.microboot.service.IDeptService;import com.example.microboot.vo.Dept;@Servicepublic class DeptService implements IDeptService &#123; @Resource private IDeptDAO deptDAO; @Override public List&lt;Dept&gt; list() &#123; return this.deptDAO.list(); &#125; @Override public boolean add(Dept dept) &#123; return deptDAO.add(dept); &#125;&#125;Dept.xml123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.example.microboot.dao.IDeptDAO"&gt; &lt;select id="list" resultType="com.example.microboot.vo.Dept"&gt; select deptno, dname from dept &lt;/select&gt; &lt;insert id="add" parameterType="com.example.microboot.vo.Dept"&gt; insert into dept(dname) values (#&#123;dname&#125;) &lt;/insert&gt;&lt;/mapper&gt;编写测试类123456@Testpublic void testAdd() throws SQLException &#123; Dept dept = new Dept(); dept.setDname("测试部门"); System.out.println(this.deptService.add(dept));&#125;此时运行测试程序报错，4、如果在实际的工作之中，对于更新操作应该强制性的启动一个事务控制才对；12@Transactional(propagation = Propagation.REQUIRED)boolean add(Dept dept);此时应该明确的表示该操作方法应该启动有一个事务的配置项。5、 在使用Spring+MyBatis里面处理的时候应该考虑到信息显示问题，所以此处建议使用logback日志组件来进行日志信息的配置；a) 将logback-spring.xml配置文件拷贝到src/main/resources目录之中；123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true"&gt; &lt;include resource="org/springframework/boot/logging/logback/base.xml" /&gt; &lt;logger name="org.springframework.web" level="INFO"/&gt; &lt;logger name="druid.sql.Statement" level="DEBUG" /&gt; &lt;logger name="com.example.microboot.dao" level="TRACE" /&gt;&lt;/configuration&gt;b) 在项目之中去引入logback的依赖程序文件；1234&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt;&lt;/dependency&gt;c) 在正常情况下mybatis的日志信息的输出操作必须设置其对应的命名空间，在logback.xml中追加如下信息；1&lt;logger name="com.example.microboot.dao" level="TRACE" /&gt;四、Druid监控Druid数据库连接池之所以使用非常广泛，其最主要的原因在于它可以直接提供性能监控。那么本次来针对于当前已经实现好的druid配置来进行性能监控的处理配置。1、如果要想进行Druid的性能的监控操作，则需要做一些基础配置，例如：访问的IP地址是否是白名单。12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.example.microboot.config;import javax.sql.DataSource;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;@Configurationpublic class DruidConfig &#123; /** * 主要实现WEB监控的配置处理 */ @Bean public ServletRegistrationBean druidServlet() &#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); // 要进行druid监控的配置处理操作 servletRegistrationBean.addInitParameter("allow", "127.0.0.1,192.168.74.1"); // 白名单 servletRegistrationBean.addInitParameter("deny", "192.168.74.2"); // 黑名单 servletRegistrationBean.addInitParameter("loginUsername", "admin"); // 用户名 servletRegistrationBean.addInitParameter("loginPassword", "admin"); // 密码 servletRegistrationBean.addInitParameter("resetEnable", "false"); // 是否可以重置数据源 return servletRegistrationBean; &#125; @Bean public FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new WebStatFilter()); filterRegistrationBean.addUrlPatterns("/*"); // 所有请求进行监控处理 filterRegistrationBean.addInitParameter("exclusions", "*.js,*.gif,*.jsp,*.css,/druid/*"); return filterRegistrationBean; &#125; @Bean @ConfigurationProperties(prefix = "spring.datasource") public DataSource druidDataSource() &#123; return new DruidDataSource(); &#125;&#125;2、为了更好的说明问题，建议建立一个控制器进行业务层的调用；1234567891011121314151617181920212223package com.example.microboot.controller;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import com.example.microboot.service.IDeptService;import com.example.microboot.vo.Dept;@Controllerpublic class DeptController &#123; @Autowired private IDeptService deptService; @RequestMapping(value = "/list", method = RequestMethod.GET) @ResponseBody public List&lt;Dept&gt; list() &#123; return this.deptService.list(); &#125;&#125;3、如果想要进行监控还需要开启一个过滤配置，而这个过滤配置的开启需要通过application.yml配置文件配置；1234567891011121314151617181920server: port: 80mybatis: config-location: classpath:mybatis/mybatis.cfg.xml # mybatis配置文件所在路劲 type-aliases-package: com.example.microboot.vo # 定义所有操作类的别名所在包 mapper-locations: # 所有的mapper映射文件 - classpath:mybatis/mapper/**/*.xmlspring: datasource: type: com.alibaba.druid.pool.DruidDataSource # 配置当前要使用的数据源的操作类型 driver-class-name: com.mysql.jdbc.Driver # 配置Mysql的驱动程序类 url: jdbc:mysql://localhost:3306/springboot # 数据库连接地址 username: root # 数据库用户名 password: admin # 数据库密码 filters: stat,wall,log4j dbcp2: # 进行数据库连接池的配置 min-idle: 5 # 数据库连接池的最小维持连接数 initial-size: 5 # 初始化提供的连接数 max-total: 5 # 最大的连接数 max-wait-millis: 200 # 等待连接获取的最大超时时间此时启动项目，访问http://localhost/druid/login.html会看到一个可视化界面；使用之前在Druid配置类中设置的用户名和密码登录即可查看监控信息；利用监控可以方便的进行程序的管理，这一点在企业开发之中至关重要。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章: SpringBoot拦截器]]></title>
    <url>%2F2017-01-15%2F%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ASpringBoot%E6%8B%A6%E6%88%AA%E5%99%A8.html</url>
    <content type="text"><![CDATA[所有的开发之中拦截器一定是一个必须要使用的功能，利用拦截器可以更加有效的实现数据的验证处理，而且在SpringBoot之中所使用的拦截器与Spring中的拦截器完全一样。一、基础拦截器1、创建一个程序的控制器类；123456789101112131415package com.example.microboot.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController &#123; @RequestMapping("/") @ResponseBody public String show() &#123; return "hello world"; &#125;&#125;2、编写一个拦截器对其进行控制，为了更好的说明问题，现在将拦截器定义在外包中；12345678910111213141516171819202122232425262728293031323334package com.example.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;public class MyInterceptor implements HandlerInterceptor &#123; private Logger log = LoggerFactory.getLogger(MyInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; log.info("[*** MyInterceptor.preHandle ***] &#123;&#125;", handlerMethod.getBean().getClass().getSimpleName()); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; log.info("[*** MyInterceptor.postHandle ***] &#123;&#125;", handlerMethod.getBean().getClass().getSimpleName()); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception modelAndView) throws Exception &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; log.info("[*** MyInterceptor.afterCompletion ***] &#123;&#125; 拦截处理完毕...", handlerMethod.getBean().getClass().getSimpleName()); &#125;&#125;3、此时如果想要使用拦截器则必须有一个拦截器的配置类，现在不在编写配置文件了，所有的配置全部利用一个类完成；123456789101112131415161718package com.example.microboot.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import com.example.interceptor.MyInterceptor;@Configurationpublic class MyConfig extends WebMvcConfigurerAdapter &#123; // 定义MVC配置 @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 注册拦截器、定义匹配路径 registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**"); super.addInterceptors(registry); &#125; &#125;现在只要找到了可以操作的控制器程序类，那么久可以依照Spring的拦截器进行相关的代码编写。二、AOP拦截器在Spring里面还提供有一种AOP拦截器配置，不过大部分的AOP拦截器都是围绕业务层进行拦截处理的。1、修改POM.xml，添加AOP依赖包；1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;2、编写一个AOP拦截的控制程序类；12345678910111213141516171819202122232425262728293031package com.example.microboot.config;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;@Aspect@Componentpublic class ServiceAspect &#123; private Logger log = LoggerFactory.getLogger(ServiceAspect.class); @Around("execution(* com.example.microboot..*.*Service.*(..))") public Object arountMethod(ProceedingJoinPoint point) &#123; Class&lt;?&gt; className = point.getTarget().getClass(); log.info("[*** ServiceAspect ***] &#123;&#125;", className); Object result = null; try &#123; // 执行目标方法 result = point.proceed(); log.info("[*** ServiceAspect ***] &#123;&#125; 执行完毕,返回结果: &#123;&#125;", className, result); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; return result; &#125;&#125;3、业务类以及控制器类；HelloController.java123456789101112131415161718192021package com.example.microboot.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.example.microboot.service.IHelloService;@Controllerpublic class HelloController &#123; @Autowired private IHelloService helloService; @RequestMapping("/") @ResponseBody public String show() &#123; return helloService.sayHello(); &#125;&#125;IHelloService.java12345package com.example.microboot.service;public interface IHelloService &#123; String sayHello();&#125;HelloService.java1234567891011121314package com.example.microboot.service.impl;import org.springframework.stereotype.Service;import com.example.microboot.service.IHelloService;@Servicepublic class HelloService implements IHelloService &#123; @Override public String sayHello() &#123; return "Hello World!!!"; &#125;&#125;对于WEB拦截可以使用拦截器，而对于业务层的拦截可以使用Aspect表达式结合AOP的拦截机制实现。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章: SpringBoot 文件上传]]></title>
    <url>%2F2017-01-15%2F%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9ASpringBoot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html</url>
    <content type="text"><![CDATA[一、基础上传操作所有只要与WEB开发牵扯到的开发框架都必须面对有文件上传处理，在原始的Spring之中所使用的上传组件是Apache的fileupload组件，在SpringBoot里面也同样要使用此组件。1、 如果要进行上传处理，则首先需要准备出相应的控制器：123456789101112131415161718192021222324252627282930package com.example.microboot.controller;import java.util.HashMap;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;@Controllerpublic class UploadController &#123; @RequestMapping("/") public String uploadPre() &#123; return "upload-page"; &#125; @RequestMapping("/upload") @ResponseBody public Map&lt;String, Object&gt; uploadPre(MultipartFile file) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); if (file != null) &#123; result.put("fileName", file.getOriginalFilename()); result.put("fileSize", file.getSize()); result.put("fileType", file.getContentType()); &#125; return result; &#125;&#125;2、编辑文件上传页面；1234567891011121314&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8" /&gt; &lt;title&gt;SpringBoot-FileUpload&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form th:action="@&#123;/upload&#125;" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" /&gt; &lt;br/&gt; &lt;input type="submit" value="上传" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;此时文件上传的基本操作就实现了。二、上传限制虽然现在已经实现了上传操作，但是这个时候的上传是没有限制的，也就是说你可以上传任意大小的文件，这一点在实际开发之中是不可能存在的，所以必须对上传进行一些限制处理。SpringBoot中默认上传限制为1M（参见MultipartProperties类源码），如果要想改变上传的限制，那么最好的做法是进行application.yml配置文件的变更；12345678910server: port: 80spring: http: multipart: enabled: true # 可以启用http上传 max-file-size: 10MB # 设置支持的单个文件上传的大小限制 max-request-size: 20MB # 设置支持的上传文件总大小限制 file-size-threshold: 512KB # 当上传文件达到指定配置量的时候会将文件内容写入磁盘 location: / # 设置上传的临时目录那么此时就可以通过以上的文件实现上传的大小限制。对于上传的配置限制，除了采用以上的配置文件编写之外，也可以单独编写一个配置程序类。范例：建立一个上传的配置程序类；12345678910111213141516171819202122232425package com.example.microboot.config;import javax.servlet.MultipartConfigElement;import org.springframework.boot.web.servlet.MultipartConfigFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class UploadConfig &#123; @Bean public MultipartConfigElement getMultipartConfig() &#123; MultipartConfigFactory configFactory = new MultipartConfigFactory(); // 设置支持的单个文件上传的大小限制 configFactory.setMaxFileSize("10MB"); // 设置支持的上传文件总大小限制 configFactory.setMaxRequestSize("20MB"); // 当上传文件达到指定配置量的时候会将文件内容写入磁盘 configFactory.setFileSizeThreshold("512kb"); // 设置上传的临时目录 configFactory.setLocation("/"); return configFactory.createMultipartConfig(); &#125; &#125;在以后的开发之中此类上传的配置程序会经常性出现。三、上传多个文件1、修改上传表单；12345&lt;form th:action="@&#123;/multiUpload&#125;" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" multiple="multiple" /&gt; &lt;br/&gt; &lt;input type="submit" value="上传" /&gt;&lt;/form&gt;2、修改文件上传处理控制器；12345678910111213141516171819@RequestMapping("/multiUpload")@ResponseBodypublic List&lt;Map&lt;String, Object&gt;&gt; multiUpload(HttpServletRequest request) &#123; List&lt;Map&lt;String, Object&gt;&gt; result = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); if (request instanceof MultipartHttpServletRequest) &#123; MultipartHttpServletRequest multipartHttpServletRequest = (MultipartHttpServletRequest) request; List&lt;MultipartFile&gt; files = multipartHttpServletRequest.getFiles("file"); for (MultipartFile file : files) &#123; if (file != null) &#123; Map&lt;String, Object&gt; item = new HashMap&lt;String, Object&gt;(); item.put("fileName", file.getOriginalFilename()); item.put("fileSize", file.getSize()); item.put("fileType", file.getContentType()); result.add(item); &#125; &#125; &#125; return result;&#125;多个上传文件的信息要通过Spring包装的Request对象获得。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六章：SpringBoot页面模版]]></title>
    <url>%2F2017-01-07%2F%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9ASpringBoot%E9%A1%B5%E9%9D%A2%E6%A8%A1%E7%89%88.html</url>
    <content type="text"><![CDATA[在整个SpringBoot之中支持最好的一个页面显示模版就是thymeleaf，而且使用此开发模版可以完全避免JSP的存在，JSP页面的最大败笔在于很多开发者会在JSP文件中编写大量的Scriptlet代码，这种代码的结构根本就不方便阅读。而且再编写JSP的时候你会发现不管如何开发都要导入一些标签库等概念，而为了简化这一切可以使用thymeleaf开发框架实现。一、信息显示在MVC的设计开发过程中，很多情况下都需要通过控制器将一些显示的内容交给页面来完成，所以首先来观察一个最简单的信息显示。1、普通的文本现在在控制器里面传输了一些简单的信息内容：12345678910111213141516package com.example.microboot.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ThymeleafController extends AbstractBaseController &#123; @RequestMapping("/") public String show(Model model) &#123; model.addAttribute("name", "张三"); model.addAttribute("age", "25"); model.addAttribute("url", "&lt;span style='color: red;'&gt;https://wwww.baidu.com&lt;span&gt;"); return "thymeleaf-show"; &#125;&#125;而后在thymeleaf-show.html页面进行数据显示时只需要通过“${属性名}”即可完成；1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8" /&gt; &lt;title&gt;SpringBoot-Thymeleaf&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text="'姓名: ' + $&#123;name&#125;" /&gt; &lt;p th:text="'年龄: ' + $&#123;age&#125;" /&gt;&lt;/body&gt;&lt;/html&gt;发现在“”元素之中出现有一个属性“th:text=“‘姓名: ‘ + ${name}””，而这个th就是thymeleaf的一个支持语法。也就是说此时表示要显示的是一个普通的文本信息。2、th:text（普通文本输出）12345model.addAttribute("name", "张三");---------------------------------------&lt;p th:text="'姓名: ' + $&#123;name&#125;" /&gt;---------------------------------------输出结果：姓名：张三读取资源文件内容：在一个项目中一定会存在资源文件，实际上使用th:text也可以获取资源文件内容123&lt;p th:text="#&#123;user.name&#125;" /&gt;&lt;p th:text="#&#123;user.age&#125;" /&gt;&lt;p th:text="#&#123;user.age('25')&#125;" /&gt;输出结果：基础运算：1&lt;p th:text="'基础运算：' + (1 + 5)" /&gt;th:utext（html输出）12345model.addAttribute("dom", "&lt;span style='color: red;'&gt;https://wwww.baidu.com&lt;span&gt;");---------------------------------------------------------------------------------&lt;p th:utext="$&#123; dom&#125;" /&gt;---------------------------------------------------------------------------------输出结果：https://wwww.baidu.com二、路径处理1、在“src/main/view/static/js”目录里面创建有一个main.js文件123onload = function() &#123; alert("页面加载完成");&#125;2、如果后续想进行方便的访问，可以使用“@{}”进行访问的定位处理；1&lt;script type="text/javascript" th:src="@&#123;/js/main.js&#125;"&gt;&lt;/script&gt;如果要想再页面中进行资源的定位一定要使用“@{路径}”完成，而且一定要使用thymeleaf标签。3、使用“@{路径}”也可以访问控制器方法；1&lt;a th:href="@&#123;/show&#125;"&gt;访问控制器方法&lt;/a&gt;如果在使用超链接的时候设置了“href”和“th:href”的话，那么前者的html元素的默认属性将无效。三、处理内置对象在这种模版开发框架里面是不提倡使用内置对象的，但是很多的开发者依然需要使用内置对象，所以下面观察如何在页面中采用内置对象。1、在控制器中追加一个方法，这个方法将采用内置对象的形式传递属性：123456@RequestMapping("/inner")public String inner(HttpServletRequest request, Model model) &#123; request.setAttribute("requestMsg", "request: Hello"); model.addAttribute("modelMsg", "model: Hello"); return "thymeleaf-inner";&#125;其中model传递的本质就属于request属性范围。2、编写页面进行内容的显示：12&lt;p th:text="$&#123;requestMsg&#125;" /&gt;&lt;p th:text="$&#123;modelMsg&#125;" /&gt;而后也可以使用“*{属性名称}”进行访问：12&lt;p th:text="*&#123;requestMsg&#125;" /&gt;&lt;p th:text="*&#123;modelMsg&#125;" /&gt;3、传递三种属性范围：12345678@RequestMapping("/inner")public String inner(HttpServletRequest request, Model model) &#123; model.addAttribute("modelMsg", "modelMsg"); request.setAttribute("requestMsg", "requestMsg"); request.getSession().setAttribute("sessionMsg", "sessionMsg"); request.getServletContext().setAttribute("applicationMsg", "applicationMsg"); return "thymeleaf-inner";&#125;1234&lt;p th:text="$&#123;modelMsg&#125;" /&gt;&lt;p th:text="$&#123;requestMsg&#125;" /&gt;&lt;p th:text="$&#123;session.sessionMsg&#125;" /&gt;&lt;p th:text="$&#123;application.applicationMsg&#125;" /&gt;4、实际上在thymeleaf里面也支持有JSP内置对象的获取操作，不过一般很少这样使用：1234&lt;p th:text="$&#123;#httpServletRequest.getRemoteAddr()&#125;" /&gt;&lt;p th:text="$&#123;#httpServletRequest.getAttribute('requestMsg')&#125;" /&gt;&lt;p th:text="$&#123;#httpSession.getId()&#125;" /&gt;&lt;p th:text="$&#123;#httpServletRequest.getServletContext().getRealPath('/')&#125;" /&gt;现在会将所有可能显示出的内容全部重新做一个模版的改写。四、对象输出1、准备一个VO类：1234567891011121314package com.example.microboot.vo;import java.io.Serializable;import java.util.Date;@SuppressWarnings("serial")public class Member implements Serializable &#123; private Long mid; private String name; private Integer age; private Date birthday; private Double salary; // getter,setter略&#125;2、编写一个控制器将对象内容进行属性传递：123456789101112131415161718192021222324package com.example.microboot.controller;import java.util.Date;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import com.example.microboot.vo.Member;@Controllerpublic class MemberController extends AbstractBaseController &#123; @RequestMapping("/member/show") public String root(Model model) &#123; Member member = new Member(); member.setMid(9527L); member.setName("张三"); member.setAge(35); member.setBirthday(new Date()); member.setSalary(9999.99); model.addAttribute("member", member); return "member-show"; &#125;&#125;3、编写页面输出：12345&lt;p th:text="'id: ' + $&#123;member.mid&#125;" /&gt;&lt;p th:text="'name: ' + $&#123;member.name&#125;" /&gt;&lt;p th:text="'age: ' + $&#123;member.age&#125;" /&gt;&lt;p th:text="'birthday: ' + $&#123;#dates.format(member.birthday,'yyyy-MM-dd')&#125;" /&gt;&lt;p th:text="'salary: ' + $&#123;member.salary&#125;" /&gt;4、经过上面的操作，发现这样的操作有点复杂，下面演示更为简单的做法：1234567&lt;div th:object="$&#123;member&#125;"&gt; &lt;p th:text="'id: ' + *&#123;mid&#125;" /&gt; &lt;p th:text="'name: ' + *&#123;name&#125;" /&gt; &lt;p th:text="'age: ' + *&#123;age&#125;" /&gt; &lt;p th:text="'birthday: ' + *&#123;#dates.format(birthday,'yyyy-MM-dd')&#125;" /&gt; &lt;p th:text="'salary: ' + *&#123;salary&#125;" /&gt;&lt;/div&gt;区别：关于“${属性}”和“*{属性}”区别?这两种属性访问机制再访问单独或者是完整属性时候是一样的，而如果要使用“*{属性}”形式进行访问往往需要结合“th:object”作为整体对象的声明后才可以直接访问；$访问完整信息，而*访问指定对象中的属性内容，如果访问的只是普通的内容两者没有区别。五、逻辑判断所有的页面模版都一定存在有各种基础逻辑，例如：判断、循环处理。在Thymeleaf之中对于逻辑可以使用如下运算符完成，例如：and、or、关系比较（&gt;、&lt;、&gt;=、&lt;=、==、!= 、gt、lt、ge、le、eq、ne）。1、通过控制器传递一些属性内容到页面中；123&lt;span th:if="$&#123;age lt 18&#125;"&gt; 未成年禁止入内&lt;/span&gt;2、除了这种做法之外还可以实现不满足条件的判断；123&lt;span th:unless="$&#123;age gt 18&#125;"&gt; 未成年禁止入内&lt;/span&gt;3、在开发之中还会使用到swith这样的语句来进行多内容的判断；12345&lt;span th:switch="$&#123;name&#125;"&gt; &lt;p th:case="王五"&gt;我是王五&lt;/p&gt; &lt;p th:case="李四"&gt;我是李四&lt;/p&gt; &lt;p th:case="*"&gt;没有匹配成功的数据&lt;/p&gt;&lt;/span&gt;在Thymeleaf中实现的switch语句之中并没有default的存在，如果需要使用default功能，就采用“th:case=“\“*”来实现。六、迭代输出​ 数据迭代是模版语言之中一个重要的组成部分，也是所有项目开发之中的重要组成部分，那么下面进行迭代操作的实现，而在实际的开发之中进行数据的迭代类型往往会有两类：List、Map。1、 建立一个控制器，在控制器中追加一个List集合和一个Map集合数据；123456789101112131415161718192021222324/** * 迭代输出 */@RequestMapping("/foreach")public String foreach(Model model) &#123; List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(3); for (int i = 1; i &lt;= 5; i++) &#123; Map&lt;String, Object&gt; item = new HashMap&lt;String, Object&gt;(); item.put("id", i); item.put("name", "王五-" + i); list.add(item); &#125; model.addAttribute("list", list); Map&lt;String, Map&lt;String, Object&gt;&gt; map = new HashMap&lt;String, Map&lt;String, Object&gt;&gt;(); for (int i = 1; i &lt;= 5; i++) &#123; Map&lt;String, Object&gt; item = new HashMap&lt;String, Object&gt;(); item.put("id", i); item.put("name", "王五-" + i); map.put("item" + i, item); &#125; model.addAttribute("map", map); return "thymeleaf-foreach";&#125;2、模版页面输出；1234567891011121314151617181920212223&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="item:$&#123;list&#125;"&gt; &lt;td th:text="$&#123;item.id&#125;" /&gt; &lt;td th:text="$&#123;item.name&#125;" /&gt; &lt;/tr&gt;&lt;/table&gt;&lt;!-- 迭代Map --&gt;&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;KEY&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="item:$&#123;map&#125;"&gt; &lt;td th:text="$&#123;item.key&#125;" /&gt; &lt;td th:text="$&#123;item.value.id&#125;" /&gt; &lt;td th:text="$&#123;item.value.name&#125;" /&gt; &lt;/tr&gt;&lt;/table&gt;在页面迭代Map的时候，每一次取得的迭代数据类型一定都是Map.Entry对象，所以一定是通过getKey()、getValue()方法获取相应的数据内容。3、在Thymeleaf输出的时候还可以输出更加强大的内容；12345678910111213141516&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;奇数&lt;/th&gt; &lt;th&gt;偶数&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="item,itemState:$&#123;list&#125;"&gt; &lt;td th:text="$&#123;itemState.index + 1&#125;" /&gt; &lt;td th:text="$&#123;item.id&#125;" /&gt; &lt;td th:text="$&#123;item.name&#125;" /&gt; &lt;td th:text="$&#123;itemState.even&#125;" /&gt; &lt;td th:text="$&#123;itemState.odd&#125;" /&gt; &lt;/tr&gt;&lt;/table&gt;七、包含处理所有的项目开发之中页面的互相包含是一项非常重要的技术支持，而在Thymeleaf也同样支持有数据的包含处理，而对于包含操作，再Thymeleaf模版之中提供有两种支持语法：th:replace：是使用标签进行替换；th:include：是进行包含；1、定义被包含的页面，于是建立“src/main/view/templates/commons/footer.html”页面；1234&lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8" /&gt;&lt;footer th:fragment="companyInfo"&gt; &lt;p&gt;D.Jang个人博客(http://www.amorouser.club)&lt;/p&gt;&lt;/footer&gt;2、进行页面包含操作；12&lt;div th:replace="@&#123;/commons/footer&#125; :: copy" /&gt;&lt;div th:include="@&#123;/commons/footer&#125; :: copy" /&gt;3、在很多的开发之中都需要向被包含页面进行参数的传递，于是，在Thymeleaf之中也可以实现，使用“th:with”完成；修改被包含页面：footer.html：12345&lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8" /&gt;&lt;footer th:fragment="copy"&gt; &lt;p&gt;D.Jang个人博客(www.amorouser.club)&lt;/p&gt; &lt;p th:text="$&#123;year&#125;" /&gt;&lt;/footer&gt;而后在进行包含处理的时候进行参数传递：1&lt;div th:include="@&#123;/commons/footer&#125; :: copy" th:with="year=2017,month=10,day=24"/&gt;那么此时就可以利用此技术与一些其他的的前端开发框架进行整合。八、数据处理在Thymeleaf之中提供有相应的集合处理方法，例如：在使用List集合的时候可以考虑采用get()方法获取指定索引的数据，在使用Set()集合的时候会考虑使用contains()来判断摸个数据是否存在，使用Map集合的时候也希望使用containsKey()判断某个Key是否存在，以及使用get()根据key获取对应的value，而这些功能在之前并不具备，下面来观察如何在页面中使用此类操作。123456789101112131415161718192021222324252627@RequestMapping("/data")public String data(Model model) &#123; List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(5); for (int i = 1; i &lt;= 5; i++) &#123; Map&lt;String, Object&gt; item = new HashMap&lt;String, Object&gt;(); item.put("id", i); item.put("name", "王五-" + i); list.add(item); &#125; model.addAttribute("list", list); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); for (int i = 1; i &lt;= 5; i++) &#123; Map&lt;String, Object&gt; item = new HashMap&lt;String, Object&gt;(); item.put("id", i); item.put("name", "王五-" + i); map.put("item" + i, item); &#125; model.addAttribute("map", map); Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add("JAVA"); set.add("PHP"); set.add("C#"); model.addAttribute("set", set); return "thymeleaf-data";&#125;1、通过Map集合获取信息；12&lt;p th:text="$&#123;#maps.containsKey(map,'item3')&#125;" /&gt;&lt;p th:text="$&#123;map['item3'].name&#125;" /&gt;2、判断某个数据是否存在；123456789&lt;p th:text="$&#123;#maps.containsKey(map,'item3')&#125;" /&gt;&lt;p th:text="$&#123;map['item3'].name&#125;" /&gt;&lt;p th:text="$&#123;#sets.contains(set,'JAVA')&#125;" /&gt;&lt;p th:text="$&#123;#sets.contains(set,'C')&#125;" /&gt;&lt;p th:text="$&#123;#sets.size(set)&#125;" /&gt;&lt;p th:text="$&#123;#lists.contains(list,'C')&#125;" /&gt;&lt;p th:text="$&#123;#lists.size(list)&#125;" /&gt;如果真进行了集合类型的修改实际上发现进行页面操作也同样保持不变。而且可以发现在页面之中都可以根据所以取得，而不关心是Set集合还是List集合：3、在进行数据处理的时候字符串数据也是一个常见的类型，所以在Thymeleaf之中也支持有字符串的操作；123&lt;p th:text="$&#123;#strings.replace('www.amorouser.club','.','$')&#125;" /&gt;&lt;p th:text="$&#123;#strings.toUpperCase('www.amorouser.club')&#125;" /&gt;&lt;p th:text="$&#123;#strings.trim(' www.amorouser.club ')&#125;" /&gt;4、日期格式化：12&lt;p th:text="$&#123;#dates.format(mydate,'yyyy-MM-dd')&#125;" /&gt;&lt;p th:text="$&#123;#dates.format(mydate,'yyyy-MM-dd HH:mm:ss')&#125;" /&gt;可以发现模版的页面设计比传统的JSP强大很多。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章: SpringBoot整合Tomcat]]></title>
    <url>%2F2017-01-07%2F%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9ASpringBoot%E6%95%B4%E5%90%88Tomcat.html</url>
    <content type="text"><![CDATA[SpringBoot本身支持有两类的WEB容器：默认的Tomcat、Jetty， 在SpringBoot程序运行的时候，即使没有WEB容器，也可以采用自定义的方式实现WEB容器的启动。如果现在只是作为一个简单的服务发布，的却用不上Tomcat,可以Tomcat也有自身的优势，毕竟它是一个具备完全功能的WEB容器，而且再这个容器里面还可以进行各种容器的服务配置，所以一些开发者认为，不应该只是纯粹的去使用微服务的方式来启动WEB程序，我们的程序还应该发布到其他WEB容器中，比如Tomcat。一、配置Tomcat运行1、如果一个程序项目需要发布到Tomcat上运行，那么该项目一定要设置为war文件修改项目类型为war文件，于是首先第一步就需要修改项目的类型为war，修改pom.xml配置文件；首先将打包的类型设置为war文件：1&lt;packaging&gt;war&lt;/packaging&gt;修改后会提示一个项目错误信息：解决方法：以上错误提示意思是没有WEB-INFO/web.xml文件打包部署到tomcat在进行以上完成以上的操作后，启动tomcat服务器，然后访问程序路径，发现并不能访问到程序，而且在tomcat启动日志中也没有SpringBoot启动的相关日志，如果想要以tomcat的形式运行，那么必须对SpringBoot的启动类做一个简单的处理2、删掉microboot-tomcat中的pom.xml里的jetty依赖库3、修改SpringBoot的启动类12345678910111213141516171819package com.example.microboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.support.SpringBootServletInitializer;@SpringBootApplication // 启动SpringBoot程序,而后自带子包扫描public class StartSpringBootMain extends SpringBootServletInitializer &#123; // 必须继承指定的父类 @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(StartSpringBootMain.class); &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(StartSpringBootMain.class, args); &#125;&#125;4、将项目进行打包，运行。二、Https访问控制之前实现了Tomcat的正常部署访问，但是再实际中可以正常的进行https的处理才是现阶段开发的重点所在。现在可以在本地做一个简单的https访问配置，正常来讲https的访问是需要有证书的，为了保证证书的安全一定要在项目之中使用CA进行认证。下面只是再本机做一个简单的模拟，利用java提供的keytool命令实现证书的生成。1、使用命令行方式进入到D:/路径下，随后进行证书的生成：1keytool -genkey -alias mytomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650 -dname “CN=Web Service,OU=Unit,O=Organization,L=City,S=State,C=US” –storepass springboot该服务器端证书生成的名称为“keystore.p12”,别名设置为了“mytomcat”，密码设置为“springboot”随后执行命令后会在D:/目录下生成一个文件：2、将该整数保存到项目之中（只要是classpath路径下即可），本次将其保存再“src/main/resourse”目录之中；3、修改application.yml文件配置ssl安全访问：1234567server: port: 443 # https的端口设置为443 ssl: key-store: class:keystore.p12 # key-store配置文件路径 key-store-type: PKCS12 # key-store类型 key-alias: mytomcat # 设置的别名 key-password: springboot # 访问密码需要注意一个问题，如果项目之中设置了maven的“”之后，一定要保证该配置文件可以正常使用。4、修改【microboot】项目中的pom.xml的资源配置项12345678910&lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.yml&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.tld&lt;/include&gt; &lt;include&gt;**/*.p12&lt;/include&gt; &lt;/includes&gt;&lt;/resource&gt;修改完成后一定要进行Maven/Update处理。如果现在443端口没有被其他程序暂用，那么此时一定可以正常启动，可是如果端口被占用，那么启动将失败，本机现在是被chrome.exe进程所占用了443端口。5、如果现在要进行醒目的执行测试不能够使用google浏览器，因为google浏览器可定无法访问，即时使用的是ForFox浏览器也不能正常访问，因为没有CA。访问：https://localhost/；6、但是也需要考虑一个问题，如果用户现在没有通过https访问，所以最好的做法是如果现在是进行了http访问，则应该让请求跳转到https的443端口上。如果要想实现这样的处理需要追加一个配置程序类：123456789101112131415161718192021222324252627282930313233343536373839404142package com.example.microboot.config;import org.apache.catalina.Context;import org.apache.catalina.connector.Connector;import org.apache.tomcat.util.descriptor.web.SecurityCollection;import org.apache.tomcat.util.descriptor.web.SecurityConstraint;import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * 负责HTTP的连接相关配置 */@Configurationpublic class HttpConnectorConfig &#123; public Connector initConnetor() &#123; Connector connetor = new Connector("org.apache.coyote.http11.Http11NioProtocol"); connetor.setScheme("http"); // 如果现在用户使用普通http的方式进行访问 connetor.setPort(80); // 用户访问的是80端口 connetor.setSecure(false); // 如果该链接为跳转则表示不是一个新的连接对象 connetor.setRedirectPort(443); // 设置转发操作端口 return connetor; &#125; @Bean public TomcatEmbeddedServletContainerFactory servletContainerFactory() &#123; TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedServletContainerFactory() &#123; // 该方法主要进行请求处理的上下文配置 protected void postProcessContext(Context context) &#123; SecurityConstraint securityConstraint = new SecurityConstraint(); // 定义新的安全访问策略 securityConstraint.setUserConstraint("CONFIDENTIAL"); // 定义用户的访问约束要求 SecurityCollection collection = new SecurityCollection(); collection.addPattern("/*");// 匹配所有的访问映射路径 securityConstraint.addCollection(collection); // 追加路径映射访问配置 context.addConstraint(securityConstraint); &#125;; &#125;; factory.addAdditionalTomcatConnectors(this.initConnetor()); return factory; &#125;&#125;如果以后用户要访问80端口，则会将其自动跳转到443端口。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章：SpringBoot错误处理]]></title>
    <url>%2F2017-01-07%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9ASpringBoot%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[一、数据验证错误处理现在假设要进行表单信息提交，可定需要一个表单，而这个表单要讲数据提交到VO类中，所以现在基本实现如下：1、建立一个Member.java的VO类；12345678910111213141516171819202122package com.example.microboot.vo;import java.io.Serializable;import java.util.Date;public class Member implements Serializable &#123; private static final long serialVersionUID = -4383124782868942630L; private String mid; private String name; private Integer age; private Double salary; @DateTimeFormat(pattern = "yyyy-MM-dd") private Date birthday; // getter,setter略&#125;2、建立MemberController控制类；1234567891011121314151617181920212223package com.example.microboot.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.example.microboot.vo.Member;@Controller@RequestMapping("/member")public class MemberController extends AbstractBaseController &#123; @RequestMapping("/add") public String add() &#123; return "/member/member-add"; &#125; @RequestMapping("/save") @ResponseBody public Object save(Member member) &#123; return member; &#125;&#125;3、编写一个页面进行用户的表单填写（在src/main/view/templates下建立）：member/member-add.html；123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8" /&gt; &lt;title&gt;Member信息添加&lt;/title&gt; &lt;link rel="icon" type="image/x-icon" href="/images/avatar.icon" /&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="/member/save" method="post"&gt; 用户邮箱: &lt;input type="text" name="mid" value="666666@gmail.com" /&gt;&lt;br /&gt; 用户姓名: &lt;input type="text" name="name" value="张三" /&gt;&lt;br /&gt; 用户年龄: &lt;input type="text" name="age" value="25" /&gt;&lt;br /&gt; 用户工资: &lt;input type="text" name="salary" value="5000.00" /&gt;&lt;br /&gt; 用户生日: &lt;input type="text" name="birthday" value="1992-10-02" /&gt;&lt;br /&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;4、此时的代码只是最为普通的操作，但是这时对于改程序也是存在一些问题的；如果有些数据没有输入，则内容是null，如果要进行严格控制，这写null不应该存在某些数据应该进行格式验证，例如：用户邮箱应该是邮箱，这个信息应该进行邮箱验证；所以现在如果想要进行这些的验证，SpringBoot里面提供有默认的支持，只不过这些支持未必是最好的，在SpringBoot中为了用户编写认证专门提供有一个hibernate-validation.jar工具包，这个工具包是有hibernate开发框架提供的。6、如果要想验证，那么首先要解决的问题就是错误提示信息问题，而在SpringBoot中对于错误信息的保存，都要求其保存在ValidationMessages.properties文件，在“src/main/resources”目录中建立此文件；1234567member.mid.notblank.error=用户名不允许为空!member.mid.email.error=用户邮箱格式不正确!member.age.notnull.error=年龄不允许为空!member.age.digits.error=年龄必须输入合法数字!member.salary.notnull.error=工资不允许为空!member.salary.digits.error=工资必须输入合法数字!member.birthday.notnull.error=生日不允许为空!提示：一个表单就需要编写这么多配置项，那么如果要有几百个表单呢？所以最好的数据检测还是利用拦截器处理最合适。7、修改Member.java程序类追加验证的处理方式；123456789101112131415161718192021222324252627282930313233package com.example.microboot.vo;import java.io.Serializable;import java.util.Date;import javax.validation.constraints.Digits;import javax.validation.constraints.NotNull;import org.hibernate.validator.constraints.Email;import org.springframework.format.annotation.DateTimeFormat;public class Member implements Serializable &#123; private static final long serialVersionUID = -4383124782868942630L; @NotNull(message = "&#123;member.mid.notblank.error&#125;") @Email(message = "&#123;member.mid.email.error&#125;") private String mid; private String name; @NotNull(message = "&#123;member.age.notnull.error&#125;") @Digits(integer = 3, fraction = 0, message = "&#123;member.age.digits.error&#125;") private Integer age; @NotNull(message = "&#123;member.salary.notnull.error&#125;") @Digits(integer = 20, fraction = 2, message = "&#123;member.salary.digits.error&#125;") private Double salary; @DateTimeFormat(pattern = "yyyy-MM-dd") @NotNull(message = "&#123;member.birthday.notnull.error&#125;") private Date birthday; // getter,setter略&#125;8、修改MemberController类中的save()方法来观察错误提示信息：1234567891011121314@RequestMapping("/save")@ResponseBodypublic Object save(@Valid Member member, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; // 现在表示执行的验证出现错误 Iterator&lt;ObjectError&gt; iterator = bindingResult.getAllErrors().iterator(); while (iterator.hasNext()) &#123; ObjectError error = iterator.next(); // 取出每一个错误 System.out.println("【错误信息】:" + error.getCode() + ", message = " + error.getDefaultMessage()); &#125; return bindingResult.getAllErrors(); &#125; else &#123; return member; &#125;&#125;二、配置错误页错误页绝对是所有的WEB项目之中必须具有的一项信息显示处理，但是再传统的WEB项目的开发之中，错误页是再web.xml之中进行配置的，不过SpringBoot中并没有web.xml配置文件，如果要想使用错误页，最好的做法是根据每一个错误代码创建一个属于自己的错误显示页。1、所有的错误页都是普通的静态文件，那么建议再“src/main/view/static”目录下创建几个常见的错误页（常见的错误页的HTTP返回状态吗：404、500、400…）：2、添加一个错误页的配置类：1234567891011121314151617181920212223242526package com.example.microboot.config;import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;import org.springframework.boot.web.servlet.ErrorPage;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.HttpStatus;@Configurationpublic class ErrorPageConfig &#123; @Bean public EmbeddedServletContainerCustomizer containerCustomizer() &#123; return new EmbeddedServletContainerCustomizer() &#123; @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; ErrorPage errorPage400 = new ErrorPage(HttpStatus.BAD_REQUEST, "/error-400.html"); ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, "/error-404.html"); ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/error-500.html"); container.addErrorPages(errorPage400, errorPage404, errorPage500); &#125; &#125;; &#125;&#125;此时只要出现了错误，就会找到相应的http状态码，而后跳转到指定的错误路径上进行显示。三、全局异常处理观察以下代码，例如：现在建立一个控制器，而后这个控制器自己抛出一个异常：123456@RequestMapping("/exception")@ResponseBodypublic String exception() &#123; System.out.println("除法计算结果：" + (10 / 0)); return "Hello World!";&#125;如果此时配置有错误页，那么这时候错误会同意跳转到500所在的路径页面进行错误的显示，但是如果现在希望能够显示出错误更加详细的内容呢，或者现在没有配置错误页？所以此时可以单独定义一个页面进行错误信息显示处理，而这个页面可以定义在“src/main/view/templates/error.html”，这个页面里面要求可以输出一些信息；1、定义一个全局的异常处理类：12345678910111213141516171819202122package com.example.microboot.global;import javax.servlet.http.HttpServletRequest;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.ModelAndView;@ControllerAdvicepublic class GlobalExceptionHandler &#123; private static final String DEFAULT_ERROR_VIEW = "error "; @ExceptionHandler(Exception.class) public ModelAndView defaultErrorHandler(HttpServletRequest request, Exception e) &#123; ModelAndView result = new ModelAndView(DEFAULT_ERROR_VIEW); result.addObject("url", request.getRequestURL()); result.addObject("exception", e); return result; &#125;&#125;对于全局异常信息显示除了采用跳转处理方式之外，也可以使用Rest进行显示。范例：修改全局异常处理类123456789101112131415161718192021222324252627package com.example.microboot.global;import javax.servlet.http.HttpServletRequest;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;@RestControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(Exception.class) public Object defaultErrorHandler(HttpServletRequest request, Exception e) &#123; class ErrorInfo &#123; private String message; private String url; public ErrorInfo(String message, String url) &#123; this.message = message; this.url = url; &#125; public String getMessage() &#123; return message; &#125; public String getUrl() &#123; return url; &#125; &#125; return new ErrorInfo(e.getMessage(), request.getRequestURL().toString()); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS-7-搭建生产环境]]></title>
    <url>%2F2017-01-03%2FCentOS-7-%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83.html</url>
    <content type="text"><![CDATA[CentOS-7-搭建生产环境一、Hyper-V安装CentOS-7Hyper-V是微软的一款虚拟化产品，首先要注意，Hyper-V是基于64位系统的，所以你的电脑必须是64位的Windows7或者以上。对于Windows7系统，首先要安装远程服务器管理工具（http://www.microsoft.com/zh-cn/download/details.aspx?id=7887），才能使用Hyper-V，Windows8及以上系统自带了Hyper-V，默认是关闭的，都是在控制面板里开启。1、开启Hyper-V在控制面板-&gt;程序-&gt;打开或关闭Windows功能 中启用Hyper-V。如下图所示：安装成功后可以在开始菜单中的Windows管理工具中找到。2、使用Hyper-V连接到服务器打开Hyper-V管理器，点右侧连接到服务器，然后选择本地计算机，如下图所示：这样就可以在自己的电脑上安装和使用虚拟机了，当然也可以连接到其他的计算机。为了能让虚拟机联网，先要设置一下Hyper-V的网络。如果你不知道什么是外网什么是内网，就按下面的方法操作，如果你知道，那下面的说明可以作为参考。3、创建虚拟网络交换机点击虚拟交换机管理器-&gt;新建虚拟网络交换机-&gt;外部-&gt;创建虚拟交换机。然后设置虚拟交换机的名称、选择使用的网卡等。确定之后会提示应用网络更改，选择“是”。4、创建虚拟机虚拟机的名称可以随便取，建议按照功能或者版本取，便于识别和管理。默认情况下虚拟机会放在C盘，考虑到C盘容量并不是很大，选择将虚拟机存储在其他位置（建议在Hyper-V的设置里将虚拟硬盘和虚拟机都改成其他位置，这样以后建立其他虚拟机就不用每次都改了）如果你电脑内存比较大（比如8G）可以分2G。如果比较吃紧，512M也可以的。下面这一步就是要让你的虚拟机能够联网，选择刚才建立的虚拟交换机一般情况下，10G的虚拟硬盘足已，也可以酌情分配我是用ISO文件安装CentOS-7，因此这一步要选择ISO镜像，自己按需选择。完成之后（在中间的窗口选中建立的虚拟机，然后点击右侧连接选项也会出现），选择第二个按钮启动，就可以开始虚拟机的安装了，和真机安装没什么区别。选中第一个Install CentOS 7回车，等待片刻出现如下图形界面此处需要自行设置root管理用户密码安装完成后点击重启此时我们就可以使用之前的root帐号进行登录和后续操作了。二、WinSCP连接CentOS-7使用WinSCP进行ssh连接的时候需要被连接服务器的ip地址和开放的22端口。所以首先需要查询出我们虚拟机中安装的CentOS-7的ip地址。1、查看IP地址1$ ip addr但是此时图中的结果却没有显示局域网的IP地址2、激活网卡修改/etc/sysconfig/network-scripts/ifcfg-eth0文件，将ONBOOT=no修改为ONBOOT=yes12$ cd /etc/sysconfig/network-scripts/$ vi ifcfg-eth0按【i】键进入编辑模式，并修改ONBOOT=no为ONBOOT=yes，然后按【esc】进入命令模式，输入以下命令保存并退出：1$ :wq3、重启网卡1$ service network restart执行以上命令重启网卡服务，使我们的修改生效。4、查看IP地址1$ ip addr现在可以看到我们的CentOS-7服务器已经有局域网地址，不出意外的话使用WinSCP应该能够连接上了。5、WinSCP连接CentOS-7到这里我们就基本完成了SSH客户端对虚拟机CentOS-7服务器的远程连接，此后我们就可以进行服务部署等操作了。三、准备工作1、新建开发环境目录这里我将会在usr目录下新建一个dev_home目录作为后续的容器及一些中间件安装目录12$ cd /usr$ mkdir dev_home2、安装wgetCentOS wget是一个从网络上自动下载文件的自由工具。它支持HTTP，HTTPS和FTP协议，可以使用HTTP代理. 所谓的自动下载是指，CentOS wget可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个CentOS wget下载任务，然后退出系统，CentOS wget将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与，这省去了极大的麻烦。wget可以跟踪HTML页面上的链接依次下载来创建远程服务器的本地版本，完全重建原始站点的目录结构。这又常被称作”递归下载”。在递归下载的时候，wget遵循Robot Exclusion标准(/robots.txt). wget可以在下载的同时，将链接转换成指向本地文件，以方便离线浏览。wget非常稳定,它在带宽很窄的情况下和不稳定网络中有很强的适应性.如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。1$ yum -y install wget3、关闭防火墙因为我们后续几个章节需要在宿主机上访问CentOS服务器中的一些服务，所以这里我们关闭防火墙设置，以便于后续的操作，正常情况下应该只需要开放部分端口就可以了，这里不做过多操作介绍。1$ systemctl stop firewalld.service四、JDK安装配置123456789101112# 切换工作目录$ cd /usr/dev_home# 新建java目录$ mkdir java# 切换到java目录$ cd java# 下载jdk-下载地址直接去官网选中对应的版本$ wget --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie;" https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.tar.gz# 解压压缩包$ tar xvf jdk-8u201-linux-x64.tar.gz# 修改[/etc/profile]文件，追加环境变量配置-或者直接使用WinSCP方便操作$ vi /etc/profile追加的内容如下：123export JAVA_HOME=/usr/dev_home/java/jdk1.8.0_201export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin对于/etc/profile编写完成之后是不够的，还需要最后一个步骤，就是让刚刚我们修改的文件变成有效起来，所以我们再输入一个命令，让修改生效。123456# 切换到根目录$ cd /# 使新建立的环境变量立刻生效$ source /etc/profile# 查看java版本$ java -version五、Tomcat安装配置12345678910111213141516# 切换到/usr/dev_home/目录下$ cd usr/dev_home# 新建tomcat目录$ mkdir tomcat# 切换到tomcat目录$ cd tomcat# 下载-下载地址直接去官网复制$ wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.39/bin/apache-tomcat-8.5.39.tar.gz# 解压$ tar xvf apache-tomcat-8.5.39.tar.gz# 切换到bin目录下$ cd apache-tomcat-8.5.39/bin# 默认配置启动tomcat$ ./startup.sh# 关闭tomcat$ ./shutdown.sh此时在宿主机中访问我们CentOS服务器的地址和tomcat的8080端口，如下图：此时我们的Tomcat环境就安装配置完成，至于Tomcat的一些其他配置同Windows中的操作一样，这里也不做过多讲解。六、Nginx安装配置先执行以下命令，安装Nginx依赖库,如果缺少依赖库，可能会安装失败，具体可以参考文章后面的错误提示信息。1234567$ yum install gcc-c++$ yum install pcre$ yum install pcre-devel$ yum install zlib $ yum install zlib-devel$ yum install openssl$ yum install openssl-devel1、安装nginx1234567891011121314# 切换到/usr/dev_home/目录下$ cd usr/dev_home# 新建nginx目录$ mkdir nginx# 切换到nginx目录$ cd nginx# 下载-下载地址直接去官网复制$ wget http://nginx.org/download/nginx-1.15.9.tar.gz# 解压$ tar xvf nginx-1.15.9.tar.gz# 进入安装包目录$ cd nginx-1.15.9# 配置安装选项、--prefix配置编译安装的路径，这里配置我们自己的路径，默认是/usr/local/nginx$ ./configure --prefix=/usr/dev_home/nginx/2、安装必要的库如果没有执行之前的命令，那么运行./configure命令时，会报错，如下图：找不到C编译器，所以我们还需要安装gcc工具集：1$ yum install gcc-c++Nginx的rewrite模块依赖于PCRE库，所以我们还需要安装PCRE库：12$ yum install pcre$ yum install pcre-develNginx的gzip模块依赖于zlib库，所以我们还需要安装zlib库：12$ yum install zlib $ yum install zlib-devel再次运行./configure命令：到这里如果没有出现./configure: error提示，表示当前环境可以安装nginx，也就是说gcc-c++、pcre、zlib库是必须的，如果nginx需要使用到ssl模块，那么还需要安装openssl库，不过不是必须的。3、编译nginx12$ make$ make install没有出错的话，表示nginx已经成功安装完成，默认安装位置为/usr/local/nginx，不过我们之前配置的路径是/usr/dev_home/nginx，安装完成后/usr/dev_home/nginx/nginx-1.15.9就可以删除掉了。4、启动Nginx1$ /usr/dev_home/nginx/sbin/nginx此时在宿主机中访问我们CentOS服务器的地址和nginx默认的80端口，如下图：此时我们的Nginx环境就安装配置完成，至于Nginx的一些其他配置同Windows中的操作一样，这里也不做过多讲解。5、常用命令123456789101112# 启动nginx$ /usr/dev_home/nginx/sbin/nginx# 停止$ /usr/dev_home/nginx/sbin/nginx –s stop# 有序的退出$ /usr/dev_home/nginx/sbin/nginx –s quit# 重启$ /usr/dev_home/nginx/sbin/nginx –s reload# 测试配置文件是否正常$ /usr/dev_home/nginx/sbin/nginx –t# 强制关闭$ pkill nginx七、Redis安装配置1234567891011121314# 切换到/usr/dev_home/目录下$ cd usr/dev_home# 新建redis目录$ mkdir redis# 切换到redis目录$ cd redis# 下载-下载地址直接去官网复制$ wget http://download.redis.io/releases/redis-5.0.3.tar.gz# 解压$ tar xvf redis-5.0.3.tar.gz# 切换到redis安装目录下$ cd redis-5.0.3# 编译$ make完成以上面步骤后，如果没有报错，那么说明Redis已经安装成功，接下来我们说一下Redis的启动方式。1、前端模式启动1$ /usr/dev_home/redis/redis-5.0.3/src/redis-server此时我们的Redis就启动成功了，但是发现一个问题，此时我们不能做其他操作了，如果要操作必须使用Ctrl+C，同时redis-server程序结束，不建议使用此方法。2、后端模式启动修改redis.conf，把daemonize no修改成daemonize yes，保存退出；12# 启动时，指定配置文件；$ ./redis-server ../redis.conf12# 查看Redis运行情况$ ps -ef | grep redis3、内置客户端连接123456# 没有密码启动$ ./redis-cli# 有密码启动$ ./redis-cli -a 密码 -h 127.0.0.1 -p 6379# 关闭Redis服务器$ ./redis-cli shutdown此时我们还没有配置密码，所以直接启动就行了4、外部客户端连接​ 完成上一步操作后我们虚拟机中的Redis内置客户端就可以连接了，但是在实际使用的肯定还会有其他局域网中的服务器需要连接Redis，此时需要关闭Redis的防火墙。更改redis.conf 文件12bind 127.0.0.1protected-mode yes更改为12# bind 127.0.0.1protected-mode no重启redis，首先Ctrl + C退出Redis客户端，再执行以下命令重启Redis服务端12$ ./redis-cli shutdown$ ./redis-server ../redis.conf成功后我们再使用宿主机的Redis客户端连接虚拟机中Redis服务关闭Redia防火墙后，建议开启密码，进行安全的连接，具体操作同Redis-Windows，这里不再赘述。八、MySQL安装配置在 Centos7 系统下使用 yum 命令安装 MySQL，需要注意的是 CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：https://dev.mysql.com/downloads/repo/yum/123456789101112131415161718192021222324252627282930$ wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm$ rpm -ivh mysql-community-release-el7-5.noarch.rpm$ yum update$ yum install mysql-server# 权限设置$ chown mysql:mysql -R /var/lib/mysql# 初始化 MySQL$ mysqld --initialize# 启动 MySQL$ systemctl start mysqld# 查看 MySQL 运行状态$ systemctl status mysqld# 验证 MySQL 安装$ mysqladmin --version# 使用 MySQL Client(Mysql客户端) 执行简单的SQL命令$ mysql# Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码$ mysqladmin -u root password "admin";# 连接到Mysql服务器$ mysql -u root -p 'admin'# 进行授权操作：mysql&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'admin' WITH GRANT OPTION;# 重载授权表：FLUSH PRIVILEGES;此时我们可以在宿主机或者局域网中的其他计算机中使用MySQL客户端进行连接。再次尝试就可以连接到MySQL数据库了。CentOS防火墙CentOS7使用firewalld打开关闭防火墙与端口1、firewalld的基本使用启动： systemctl start firewalld关闭： systemctl stop firewalld查看状态： systemctl status firewalld开机禁用 ： systemctl disable firewalld开机启用 ： systemctl enable firewalld2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl –failed3.配置firewalld-cmd查看版本： firewall-cmd –version查看帮助： firewall-cmd –help显示状态： firewall-cmd –state查看所有打开的端口： firewall-cmd –zone=public –list-ports更新防火墙规则： firewall-cmd –reload查看区域信息: firewall-cmd –get-active-zones查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0拒绝所有包：firewall-cmd –panic-on取消拒绝状态： firewall-cmd –panic-off查看是否拒绝： firewall-cmd –query-panic4.那怎么开启一个端口呢添加（–permanent永久生效，没有此参数重启后失效）：firewall-cmd –zone=public –add-port=80/tcp –permanent重新载入：firewall-cmd –reload查看：firewall-cmd –zone= public –query-port=80/tcp删除：firewall-cmd –zone= public –remove-port=80/tcp –permanentyum使用阿里云镜像yum的默认地址下载太慢，所以用国内比较稳定的阿里云源。12345678910111213# 1、备份$ mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup# 2、下载新的CentOS-Base.repo 到/etc/yum.repos.d/## CentOS 5$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo## CentOS 6$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo## CentOS 7$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo# 3、生成缓存$ yum makecache]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章：SpringBoot配置深入]]></title>
    <url>%2F2017-01-02%2F%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9ASpringBoot%E9%85%8D%E7%BD%AE%E6%B7%B1%E5%85%A5.html</url>
    <content type="text"><![CDATA[在之前已经基本上了解了整个SpringBoot运行机制，但是也需要清楚的认识到以下的问题，在实际的项目开发之中，尤其是Java的MVC版项目，所有的项目都一定需要满足于如下几点要求：访问的端口不能够是8080，应该使用默认的80端口；在项目之中为了方便进行数据的维护，建议建立一系列的*.properties配置文件，例如：提示消息、跳转路径；所有的控制器现在都采用了Rest风格输出，但是正常来讲，信息的显示应该交给页面（不再是JSP）负责完成；在进行项目打包的时候，应该考虑到不同的profile配置。改变环境属性通过当前的执行可以发现，默认情况下，在SpringBoot里面启动WEB容器为Tomcat：1INFO 15400 --- [main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)properties配置文件从实际的开发来讲，我们的WEB部署项目如果是单独运行不可能运行再8080端口上，从正常来讲我们的服务器应该运行在80端口上，如果要想修改这样的默认环境，则必须编写与之对应的配置文件，该配置文件一定要卸载classpath之中，例如：项目中的“src/main/resources”就是一个classpath路径，那么这个目录之中直接创建有一个application.properties（文件名称一定不要改变）。范例：定义application.properties配置文件12# 设置Tomcat的运行服务所在端口server.port=80随后重新运行程序会出现有如下的提示信息：“Tomcat started on port(s): 80 (http)”范例：如果有需要也可以配置contextPath的信息1234# 设置Tomcat的运行服务所在端口server.port=80# 可以配置ContextPath访问路径，但是在实际开发之中是不能够进行配置的server.context-path=/base此时的访问路径需要最佳contextPath前缀：http://localhost/base/严格来讲在SpringBoot、SpringCloud里面可以使用两类配置文件：application.properties、application.yml。yml配置文件YAML文件：这是一种结构话的文件数据，其在很多的地方上都使用过，例如：Apache Storm开发组件上进行配置的时候使用的就是yml配置文件，该配置文件的全称（Yet Another Markup Languange、仍然是一种标记语言）范例：定义application.yml文件12server: port: 80 # 此处设置的服务访问的端口配置无聊的测试：如果application.properties和application.yml两个文件同时存在使用哪个？那么这个时候优先使用application.properties配置文件的加载，如果现在两个配置项的作用冲突了，则以properties为主，如果不冲突，则以存在的为主。在之前默认使用的WEB容器是Tomcat容器，实际上再SpringBoot里面如果用户有需要也可以将容器更换为jetty容器，如果现在要想使用这个容器，则只需要增加一些依赖即可。1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;如果在以后项目以微服务的方式进行打包发布的时候，强烈建议使用jetty服务进行发布。读取资源文件在实际的项目开发之中资源文件一定不可或缺，因为所有的提示文字信息都要求再资源文件之中进行定义，而且资源文件是实现国际化技术的主要手段。如果要想在SpringBoot里面进行资源文件的配置只需要做一些简单的application.yml配置即可，而且所有注入的资源文件都可以像最初的Spring处理那样直接使用MessageSource进行读取。为了统一管理资源文件，在“src/main/resources”目录之中建立有一个i18n的存储目录。在“src/main/resources/i18n”目录之中建立有两个资源目录：建立Messages.properties：12welcome.url=com.example.springbootwelcome.msg=欢迎&#123;0&#125;光临!建立Pages.properties配置文件：12member.add.page=/pages/back/admin/member/member_add.jspmember.add.action=/pages/back/admin/member/member_add.action修改application.yml文件：123456server: port: 80 # 此处设置的服务访问的端口配置spring: # 表示该配置直接为Spring容器负责处理 messages: # 表示进行资源配置 basename: i18n/Messages,i18n/Messages.pages # 资源文件的名称当执行完以上的配置之后会自动为用户创建MessageSource对象，那么用户再使用的时候直接注入此对象即可。考虑到实际开发的标准性，所以现在建议创建一个父的控制器的抽象类；AbstractBaseController；在此抽象类之中进行资源读取类的配置。1234567891011121314package com.example.microboot.controller;import java.util.Locale;import javax.annotation.Resource;import org.springframework.context.MessageSource;public abstract class AbstractBaseController &#123; @Resource private MessageSource messageSource; public String getMessage(String key, String... args) &#123; return messageSource.getMessage(key, args, Locale.getDefault()); &#125;&#125;在控制器的子类之中读取配置信息12345678910111213package com.example.microboot.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class MessageController extends AbstractBaseController &#123; @RequestMapping("/message") public String message(String mid) &#123; System.out.println("访问地址：" + super.getMessage("member.add.page")); return super.getMessage("welcome.msg", mid); &#125;&#125;编写一个JUnit测试类，来测试以上的控制器程序是否正确。12345678910111213141516171819202122package com.example.microboot;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import com.example.microboot.controller.MessageController;@SpringBootTest(classes = StartSpringBootMain.class)@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfigurationpublic class MessageControllerTest &#123; @Autowired private MessageController messageController; @Test public void test() &#123; System.out.println(messageController.message("张三")); &#125;&#125;通过整个SpringBoot执行可以清楚的发现，再SpringBoot里面所有对象信息的注入配置操作，都直接通过一行简单的字符串实现了，而且最终也能够保持与之前同样的运行效果。代码下载: microboot-configure]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章：SpringBoot基础知识]]></title>
    <url>%2F2017-01-02%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9ASpringBoot%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[在第一章所建立的SpringBoot项目只是根据官方文档实现的一个基础程序模型，但是这样的代码肯定不适合于实际的项目开发，因为从实际的Maven项目来讲，应该要有统一的父pom.xml文件。统一父pom管理首先建立一个microboot的Maven项目：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;microboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;microboot&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;jdk.version&gt;1.8&lt;/jdk.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;springboot.version&gt;1.5.7.RELEASE&lt;/springboot.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;springboot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;finalName&gt;microboot-base&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;$&#123;jdk.version&#125;&lt;/source&gt;&lt;!-- 需要生成的目标class文件的编译版本 --&gt; &lt;target&gt;$&#123;jdk.version&#125;&lt;/target&gt; &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;modules&gt; &lt;module&gt;microboot-base&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt;建立microboot-basede 子模块，实现第一章的SpringBoot程序，修改pom.xml文件，追加SpringBoot的WEB启动包12345678910111213141516171819202122232425262728293031323334353637&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;microboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microboot-base&lt;/artifactId&gt; &lt;name&gt;microboot-base&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;jdk.version&gt;1.8&lt;/jdk.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;microboot-base&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;$&#123;jdk.version&#125;&lt;/source&gt;&lt;!-- 需要生成的目标class文件的编译版本 --&gt; &lt;target&gt;$&#123;jdk.version&#125;&lt;/target&gt; &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;建立与之前一样的程序类；123456789101112131415161718192021package com.example.microboot;import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@Controller@EnableAutoConfigurationpublic class SampleController &#123; @RequestMapping("/") @ResponseBody public String home() &#123; return "Hello World!"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125;&#125;在这样的状态下才可以进行后续的代码编写。SpringBoot代码测试上面的程序里面已经实现了一个最为简单的控制器程序类，不过从实际项目的角度来讲，必须考虑到代码的测试问题，而且现在的程序代码属于SpringBoot，则需要在项目之中进行如下的pom.xml文件的变更。【microboot-base模块】修改pom.xml配置文件，追加SpringBoot测试支持。12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;只要进行java测试，最简单实用的就是junit，所以这个开发包一定要随测试一起导入。【microboot-base模块】建立一个测试程序类。12345678910111213141516171819202122232425package com.example.microboot;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import junit.framework.TestCase;@SpringBootTest(classes=SampleController.class)@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfigurationpublic class SampleControllerTest &#123; @Autowired private SampleController sampleController; @Test public void test() &#123; TestCase.assertEquals(this.sampleController.home(), "Hello World!"); &#125;&#125;SpringBoot启动注解分析现在为止已经可以发现再整个SpringBoot程序里面使用了许多的注解，首先把这些注解做一个列表：table th:nth-of-type(1){width:5%}table th:nth-of-type(2){width:25%}table th:nth-of-type(3){width:70%}No注解说明1@Controller进行控制器的配置注解，这个注解所在的类就是控制器类2@EnableAutoConfiguration开启自动配置处理3@RequestMapping(“/“)表示访问的映射路径，此时的路径为“/”，访问地址：http://localhost:8080/4@ResponseBody在Restful架构之中，该注解表示直接将返回的数据以字符串或JSON的形式获得可以发现再给定的几个注解之中“@EnableAutoConfiguration”为整个SpringBoot的启动注解配置，为就是说这个注解应该随着程序的主类一起进行定义。而对于控制器程序类，由于在项目之中会有许多的控制器，那么最好将这些控制器统一保存在一个包中，下面将所有的控制器程序类保存在“com.example.microboot.controller”，是“com.example.microboot”子包。强烈建议（Spring官方建议）：如果想要进行简单方便的开发，所有的程序类一定要再启动类所在包的子包下。【microboot-base模块】建立一个com.example.microboot.controller.HelloController程序类；12345678910111213141516package com.example.microboot.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; @Controller public class HelloController &#123; @RequestMapping("/") @ResponseBody public String hello() &#123; return "Hello World!"; &#125;&#125;【microboot-base模块】启动程序主类；123456789101112131415package com.example.microboot;import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.context.annotation.ComponentScan;@EnableAutoConfiguration@ComponentScan("com.example.microboot") // 定义一个访问路径public class SampleController &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125;&#125;使用复合注解【microboot-base模块】以上的做法只是传统程序的开发做法，因为现在位置为止，毕竟是两块程序类，这两个彼此之间的联系需要有一个连接点，而程序中配置的“@ComponentScan”就是负责这个连接处理，但是SpringBoot考虑到了此类的配置问题，所以踢出了一个更简化策略，该策略的核心思想：既然程序主类会在所有开发包的父包里面，那么能不能简化点取得配置呢，为此在实际的开发中，会使用一个特殊的复合注解：12345678910111213package com.example.microboot;import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;@SpringBootApplication // 启动SpringBoot程序,而后自带子包扫描public class SampleController &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125;&#125;“@SpringBootApplicati = @EnableAutoConfiguration + @ComponentScan + 其他配置”。正式因为他有这样的特点，所以当以后使用Bean实现配置处理的时候将会非常的容易。参见源码：12345678@Target(&#123;java.lang.annotation.ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters=&#123;@org.springframework.context.annotation.ComponentScan.Filter(type=org.springframework.context.annotation.FilterType.CUSTOM, classes=&#123;org.springframework.boot.context.TypeExcludeFilter.class&#125;), @org.springframework.context.annotation.ComponentScan.Filter(type=org.springframework.context.annotation.FilterType.CUSTOM, classes=&#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;……&#125;路径访问控制在一个实际的项目开发之中，控制器的路径可能会有很多个，而且再进行控制器编写的时候也会有两种运行模式：跳转配置、Restful显示。那么下面来观察关于路径的详细描述。在之前所编写的控制器里面有如下两个注解配置使用：@Controller：在类上定义，表示定义的是控制器；@ResponseBody：将控制器中方法的返回值变为rest内容。但是如果说现在一个项目里面可能控制器之中返回的全部都是Restful信息，这样分别定义就太麻烦了，为此再SpringBoot里面又提供了一个复合注解：“@RestController”1234567891011121314package com.example.microboot.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping("/") public String hello() &#123; return "Hello World!"; &#125;&#125;因为从MVC实际标准来讲，控制器需要传递一些属性到页面上进行显示，按照这样的原则并不是所有的开发都会以Rest结构返回，但是Rest结构是SpringCloud的实现核心技术。现在所给出的控制器的类里面只是负责了简单的信息返回，那么实际上也可以进行参数的接受处理；最简单的做法是使用地址重写传递“?参数名=值”；1234@RequestMapping("/echo")public String echo(String msg) &#123; return "echo: " + msg;&#125;访问路径：http://localhost:8080/echo?msg=hello由于SpringBoot支持Rest风格处理，所以此时对于参数的接收可以采用路径参数的形式完成；1234@RequestMapping(value = "/echo/&#123;message&#125;", method = RequestMethod.GET)public String echo(@PathVariable("message") String msg) &#123; return "echo: " + msg;&#125;访问路径：http://localhost:8080/echo/hello个人建议：虽然路径参数的形式属于rest操作标准，但是个人觉得使用地址重写传递参数更加简单，不过这一点使用什么样的模式来处理，取决于所处的项目团队。热部署现在每一次类级别的操作都要重新启动项目，但是在SpringBoot的处理操作中实际上已经充分考虑到了此类情况，所以追加有自动加载配置的依赖库，实现热部署；如果现在的项目是一个简单的SpringBoot的配置项目，则显示的项目信息如下：【microboot-base模块】如果现在程序中添加有如下的两个依赖库：修改pom.xml文件；12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;引入完成之后可以观察项目上的提示信息：使用内置对象通过整个SpringBoot程序发现，再SpringBoot中的控制器的形式和SpringMVC是一样的，所以如果现在想要再程序中使用JSP的内置对象，那么也可以按照与SpringMVC同样的方式进行。12345678@RequestMapping("/object")public String object(HttpServletRequest request, HttpServletResponse response) &#123; System.out.println("*** 客户端ip：" + request.getRemoteAddr()); System.out.println("*** 取得客户端相应编码：" + response.getCharacterEncoding()); System.out.println("*** 取得SessionID：" + request.getSession().getId()); System.out.println("*** 取得真实路径：" + request.getServletContext().getRealPath("/upload/")); return "object";&#125;1234*** 客户端ip：0:0:0:0:0:0:0:1*** 取得客户端相应编码：ISO-8859-1*** 取得SessionID：B639577D43042C054C16E0C94D7D55C8*** 取得真实路径：C:\Users\D\AppData\Local\Temp\tomcat-docbase.164888899979402928.8080\upload\通过以上的信息可以发现。此时的SpringBoot运行依然需要有一个工作目录，只不过这个工作目录是由SpringBoot自己定义的，主要就是当前用户的目录下存在项目打包部署SpringBoot作为微架构实现主要技术，其发布项目的方式极为简单，只需要你在你的项目中配置号插件，以及打包就可以进行了，并且这个执行不需要特别复杂的配置。添加打包发布处理插件【microboot项目】修改pom.xml配置文件，追加新的插件：1234567891011121314&lt;plugin&gt; &lt;!-- 该插件主要功能是进行项目的打包发布处理 --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 设置程序执行的主类 --&gt; &lt;mainClass&gt;com.example.microboot.StartSpringBootMain&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;由于增加了新的插件，所以对于整个程序一定要进行整体的项目更新。打包【microboot-base模块】将当前项目模块进行打包处理：clean package；此时形成“microboot.jar”程序文件，并且这个文件里面包含有全部的依赖支持库文件；部署运行将“microboot.jar”文件随意拷贝到一个路径之中，例如：D盘，而后进入到命令行方式下：1java -jar microboot.jar如果此时想要再Linux下执行，只需要将这个*.jar文件直接上传到Linux下，再执行以上命令即可。代码下载: microboot-base]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章：SpringBoot入门]]></title>
    <url>%2F2017-01-02%2F%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9ASpringBoot%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[SpringBoot简介长期以来Java的开发一直让人所诟病：Java项目开发复杂度极其高；Java项目的维护非常困难；在云时代如何实现项目的快速部署以及快速启动；即便使用了大量的开发框架，发现我们的开发也没少多少。当所有的人认为Spring不在前进的时候，Spring推出了微架构实现的两个重要开发框架：SpringBoot、SpringCloud。Java开发的复杂度是最高的？在软件行业里面，如果要说商用体系，排在第一位的永远是Java，因为Java的体系丰富，支持度高，安全性也高，但是同时所有的开发者也不得不去忍受Java中的以下痛苦：Java里面提供的开发支持都属于原生操作，例如：JDBC，如果使用Java原生代码会重复编写大量的代码，例如：PreparedStatement操作；Java进行WEB项目开发时，必须按照严格的格式进行WEB项目创建，每当修改WEB程序的时候，又需要进行Tomcat的重新启动；Java中虽然提供了所谓的开发变准，但是所有的公司几乎都有可能有自己的标准，例如：JVM最初的标准就有三个，而且许多公司由于使用的版本不同也会造成部署的环境不同；Java里面严格要求按照MVC的设计模式。以WEB开发为例，一个靓号的JSP程序代码里面不应该包含有任何的Scriptlet程序代码，但是要想做到这一步非常麻烦，有各种实现标准，例如：JSTL+EL、SpringTaglib、StratsTaglib、JSF、Shiro、SpringSecurity;如果现在使用Node.JS、Python开发一个控制器程序类可能只需要几行代码，而Java要想开发这样一个程序，需要写一堆的代码，而且还要搞部署；Java项目的维护困难？Rest技术已经开始在行业中广为流传，而Java要想实现Rest架构的开发（基于Spring），那么也是相当麻烦的。如何实现项目的快速部署以及快速启动？Java后期的发展使用了大量的Maven技术作为开发，那么使用Maven之后发现传统的开发之中并没有逃离掉传统WEB的身影，所有的项目依然需要打包为WAR文件，而后上传到系统之中。使用Maven还有一个最大的痛：如果使用开发框架，那一堆的Maven的配置依赖库。即便使用了大量的开发框架，我们的开发也没少多少？现在行业之中，Spring已经作为了绝对的Java架构，但是如果要想在Spring之中整合RabbitMQ，Kafka、ActiveMQ、MySQL，Druid、Shiro；需要编写一堆的*.xml配置文件。所以再这样的一个大的背景下，很多人开始需求更多简便的开发，而遗憾的是这种简便的开发没有被JDK所支持、没有被JavaEE所支持，因为这些只是平台，平台所能够提供的只是最原始的技术支持。这一时刻由于Spring框架的升级而得到了新生，SpringBoot的出现，改变了所有Java开发的困境，ApringBoot的最终奉行的宗旨：废除所有的复杂开发，废除掉所有的配置文件，让开发变得更简单纯粹，核心：“零配置”。SpringBoot之所以慢慢可以火遍全世界，是因为在SpringBoot中使用的大量注解还是之前Spring所提供的注解，那么这一点让所有的开发者几乎可以零适应进行完整过渡。SpringBoot快速入门本次快速启动程序将直接采用Spring官方给出的程序进行演示。新建Maven-quickstart项目如果要想进行SpringBoot开发，一定需要使用Maven或其他的项目管理工具完成。SpringBoot运行之后会以WEB程序为主，但是现在所建立的只是一个普通的quickstart程序；如果要想开发SpringBoot程序只需要按照官方给出的要求配置一个父pom即可。123456789101112131415161718192021222324252627282930313233343536373839&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-helloword&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-helloword&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;jdk.version&gt;1.8&lt;/jdk.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.7.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-boot-helloword&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;$&#123;jdk.version&#125;&lt;/source&gt;&lt;!-- 需要生成的目标class文件的编译版本 --&gt; &lt;target&gt;$&#123;jdk.version&#125;&lt;/target&gt; &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;编写一个具体的程序：123456789101112@Controller@EnableAutoConfigurationpublic class SampleController &#123; @RequestMapping("/") @ResponseBody String home() &#123; return "Hello World!"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125;&#125;而后可以直接通过Java程序运行该SpringBoot的代码。现在由于我的Eclipse使用的是STS开发插件，所以支持有SpringBoot的运行模式。如果现在是一个Maven的普通项目，最简单的做法是再maven运行的时候输入：“spring-boot:run”;总结SpringBoot的天生缺陷：是对开发者的要求比较高，会Maven、SSM整合开发。代码下载: spring-boot-helloword]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中AOP方式实现多数据源切换]]></title>
    <url>%2F2017-01-02%2FSpring%E4%B8%ADAOP%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2.html</url>
    <content type="text"><![CDATA[基于Druid数据源.动态配置多数据源负责改变上下文数据源的名称1234567891011121314151617181920212223242526package com.wesite.core.datasource;public class DataSourceContextHolder &#123; public static final String DATA_SOURCE_A = "datasource1"; public static final String DATA_SOURCE_B = "datasource2"; // 线程本地环境 private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;String&gt;(); // 设置数据源类型 public static void setDataSource(String dataSource) &#123; contextHolder.set(dataSource); &#125; // 获取数据源类型 public static String getDataSource() &#123; return (contextHolder.get()); &#125; // 清除数据源类型 public static void clearDataSource() &#123; contextHolder.remove(); &#125; &#125;建立动态数据源类这个类必须继承AbstractRoutingDataSource，且实现方法determineCurrentLookupKey，该方法返回一个Object，一般是返回字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.wesite.core.datasource;import java.util.Map;import org.apache.commons.lang.StringUtils;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;public class DynamicDataSource extends AbstractRoutingDataSource &#123; private boolean debug = false; private Map&lt;Object, Object&gt; dynamicTargetDataSources; private Object dynamicDefaultTargetDataSource; @Override protected Object determineCurrentLookupKey() &#123; String dataSource = DataSourceContextHolder.getDataSource(); if (debug) &#123; if (StringUtils.isEmpty(dataSource)) &#123; System.out.println("---当前数据源: 默认数据源---"); &#125; else &#123; System.out.println("---当前数据源：" + dataSource + "---"); &#125; &#125; return DataSourceContextHolder.getDataSource(); &#125; public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) &#123; super.setTargetDataSources(targetDataSources); dynamicTargetDataSources = targetDataSources; &#125; public void setDefaultTargetDataSource(Object defaultTargetDataSource) &#123; super.setDefaultTargetDataSource(defaultTargetDataSource); dynamicDefaultTargetDataSource = defaultTargetDataSource; &#125; public void setDebug(boolean debug) &#123; this.debug = debug; &#125; public boolean isDebug() &#123; return debug; &#125; public Map&lt;Object, Object&gt; getDynamicTargetDataSources() &#123; return dynamicTargetDataSources; &#125; public void setDynamicTargetDataSources(Map&lt;Object, Object&gt; dynamicTargetDataSources) &#123; this.dynamicTargetDataSources = dynamicTargetDataSources; &#125; public Object getDynamicDefaultTargetDataSource() &#123; return dynamicDefaultTargetDataSource; &#125; public void setDynamicDefaultTargetDataSource(Object dynamicDefaultTargetDataSource) &#123; this.dynamicDefaultTargetDataSource = dynamicDefaultTargetDataSource; &#125; &#125;编写spring的配置文件配置多个数据源12345678910111213141516171819202122232425262728293031323334&lt;bean id="multiDataSource" class="com.wesite.core.datasource.DynamicDataSource" &gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;entry value-ref="datasource1" key="datasource1"&gt;&lt;/entry&gt; &lt;entry value-ref="datasource2" key="datasource2"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="defaultTargetDataSource" ref="datasource1" /&gt; &lt;property name="debug" value="false"/&gt;&lt;/bean&gt;&lt;bean id="datasource1" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="com.ibm.db2.jcc.DB2Driver" /&gt; &lt;property name="url" value="jdbc:db2://localhost:50000/SAMPLE:currentSchema=TEST;" /&gt; &lt;property name="username" value="D" /&gt; &lt;property name="password" value="admin" /&gt; &lt;property name="initialSize" value="1" /&gt; &lt;property name="minIdle" value="1" /&gt; &lt;property name="maxActive" value="20" /&gt; &lt;property name="filters" value="stat" /&gt;&lt;/bean&gt;&lt;bean id="datasource2" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="admin" /&gt; &lt;property name="initialSize" value="1" /&gt; &lt;property name="minIdle" value="1" /&gt; &lt;property name="maxActive" value="20" /&gt; &lt;property name="filters" value="stat" /&gt;&lt;/bean&gt;1、 在这个配置中第一个property属性配置目标数据源2、中的key-type必须要和静态键值对照类DynamicDataSource中dynamicTargetDataSources的key值的类型相同3、中key的值必须要和静态键值对照类中的值相同，如果有多个值，可以配置多个&lt; entry&gt;标签。第二个property属性配置默认的数据源动态切换是数据源1DataSourceContextHolder.setDataSource(DataSourceContextHolder.DATA_SOURCE_A);配置自定义注解123456@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)public @interface DynamicDataSourceAnnotation &#123; //dataSource 自定义注解的参数 String dataSource() default DataSourceContextHolder.DATA_SOURCE_A;&#125;配置切面类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.wesite.model.datasource;import java.lang.reflect.Method;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;/** * @author D * */@Aspect@Component@Order(1)@SuppressWarnings("rawtypes")public class DynamicDataSourceAspect &#123; @Before("@annotation(com.wesite.model.datasource.DynamicDataSourceAnnotation)") //前置通知 public void testBefore(JoinPoint point)&#123; Class&lt;?&gt; className = point.getTarget().getClass(); DynamicDataSourceAnnotation dataSourceAnnotation = className.getAnnotation(DynamicDataSourceAnnotation.class); if (dataSourceAnnotation != null ) &#123; String methodName = point.getSignature().getName(); Class[] argClass = ((MethodSignature)point.getSignature()).getParameterTypes(); String dataSource = DataSourceContextHolder.DATA_SOURCE_A; try &#123; Method method = className.getMethod(methodName, argClass); if (method.isAnnotationPresent(DynamicDataSourceAnnotation.class)) &#123; DynamicDataSourceAnnotation annotation = method.getAnnotation(DynamicDataSourceAnnotation.class); dataSource = annotation.dataSource(); System.out.println("DataSource Aop ====&gt; "+dataSource); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; DataSourceContextHolder.setDataSource(dataSource); &#125; &#125; @After("@annotation(com.wesite.model.datasource.DynamicDataSourceAnnotation)") //后置通知 public void testAfter(JoinPoint point)&#123; Class&lt;?&gt; className = point.getTarget().getClass(); DynamicDataSourceAnnotation dataSourceAnnotation = className.getAnnotation(DynamicDataSourceAnnotation.class); if (dataSourceAnnotation != null ) &#123; String methodName = point.getSignature().getName(); Class[] argClass = ((MethodSignature)point.getSignature()).getParameterTypes(); String dataSource = DataSourceContextHolder.DATA_SOURCE_A; try &#123; Method method = className.getMethod(methodName, argClass); if (method.isAnnotationPresent(DynamicDataSourceAnnotation.class)) &#123; DynamicDataSourceAnnotation annotation = method.getAnnotation(DynamicDataSourceAnnotation.class); dataSource = annotation.dataSource(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if(dataSource != null &amp;&amp; !DataSourceContextHolder.DATA_SOURCE_A.equals(dataSource)) DataSourceContextHolder.clearDataSource(); &#125; &#125;&#125;在切入点添加自定义的注解123456789101112131415161718192021package com.wesite.model.service;import org.springframework.stereotype.Service;import com.wesite.model.datasource.DataSourceContextHolder;import com.wesite.model.datasource.DynamicDataSourceAnnotation;/** * @author D * */@Service@DynamicDataSourceAnnotationpublic class DynamicDataSourceService &#123; @DynamicDataSourceAnnotation(dataSource = DataSourceContextHolder.DATA_SOURCE_B) public void changeDataSource() &#123; System.out.println("切换数据源serviceImple"); &#125;&#125;当然注解扫描、和aop代理一定要在配置文件中配好1234&lt;!-- 自动扫描(bean注入) --&gt;&lt;context:component-scan base-package="com.website.*" /&gt;&lt;!-- AOP自动代理功能 --&gt;&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo：SEO设置]]></title>
    <url>%2F2017-01-01%2FHexo%EF%BC%9ASEO%E8%AE%BE%E7%BD%AE.html</url>
    <content type="text"><![CDATA[一、百度收录站点SEO（Search Engine Optimization）：汉译为搜索引擎优化。是一种方式:利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是：为网站提供生态式的自我营销解决方案，让其在行业内占据领先地位，获得品牌收益；SEO包含站外SEO和站内SEO两方面；为了从搜索引擎中获得更多的免费流量，从网站结构、内容建设方案、用户互动传播、页面等角度进行合理规划，还会使搜索引擎中显示的网站相关信息对用户来说更具有吸引力登录百度站长平台，在用户中心 =&gt; 站点管理添加你的站点网址配置完站点属性后，进入最后一步：验证网站。有三种方式：文件验证、HTML标签验证、CNAME验证，文件验证和CNAME验证都比较简单，也有相对应的帮助文本，在此我选择的是HTML标签验证。1、主题_config.yml文件在主题的_config.yml文件中，设置：baidu_site_verification: true，如果没有该字段就手动添加。2、修改head.swig在themes/next/layout/_partials/head.swig文件中添加下列代码1234// 每个人的content值都不一致，请注意更换成你的content值&#123;% if theme.baidu_site_verification %&#125; &lt;meta name="baidu-site-verification" content="6K5YmdKWEx" /&gt;&#123;% endif %&#125;3、重新发布配置好后，重新发布站点，在百度站长页面完成验证。二、百度链接提交链接提交工具是网站主动向百度搜索推送数据的工具，本工具可缩短爬虫发现网站链接时间，网站时效性内容建议使用链接提交工具，实时向搜索推送数据。本工具可加快爬虫抓取速度，无法解决网站内容是否收录问题由于github屏蔽百度的爬虫，所以使用github page服务的站点的链接无法被抓取，可用coding的page服务。1、主动推送最为快速的提交方式，建议您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。安装百度链接提交插件1npm install hexo-baidu-url-submit --save修改站点_config.yml文件，追加以下内容12345678910# 百度链接自动提交baidu_url_submit: # 提交最新的链接数量 count: 6 # 在百度站长平台中注册的域名 host: http://amorous.coding.me # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! token: # 文本文档的地址， 新链接会保存在此文本文档里 path: baidu_urls.txt修改站点_config.yml文件，修改deploye配置123456deploy: type: git repository: github: git@github.com:amorous/amorous.github.io.git,master coding: git@git.coding.net:Amorous/Amorous.git,master type: baidu_url_submitter2、自动推送是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。修改主题_config.yml文件，修改baidu_push配置1baidu_push: true新增baidu_push.swig文件在路径themes\next\layout\_scripts\下创建baidu_push.swig 文件，文件内容如下12345678910111213141516&#123;% if theme.baidu_push %&#125;&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&#123;% endif %&#125;3、sitemap您可以定期将网站链接放到Sitemap中，然后将Sitemap提交给百度。百度会周期性的抓取检查您提交的Sitemap，对其中的链接进行处理，但收录速度慢于主动推送。使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎安装sitemap插件12npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save修改hexo配置文件123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://amorous.coding.meroot: /permalink: :title/permalink_defaults:执行完之后就会在网站根目录生成sitemap.xml文件和baidusitemap.xml文件，其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件，部署后访问我们的站点http://amorous.coding.me/sitemap.xml。提交到百度站长1http://amorous.coding.me/sitemap.xml4、手动提交如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度。手动提交方式比较简单，按照官方提示就会使用 - -三、文章页面配置1、缩短页面url路径hexo 中文章页面url默认为：sitename/year/mounth/day/title，由于url层级过多爬虫不容易爬到文章，所以将页面url缩简为：sitename/title，在hexo 配置文件中修改permalink 配置项。123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://lianghuii.comroot: /permalink: :title/permalink_defaults:2、文章增加标识字段为文章增加keywords、description等标识字段，在hexo 根目录中scaffolds文件中的文章模版文件中增加。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo：性能优化]]></title>
    <url>%2F2017-01-01%2FHexo%EF%BC%9A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[Hexo 性能优化一、主题源加载优化把在NexT主题的_config.yml里面的：12# Uri of fonts host. E.g. //fonts.googleapis.com (Default)host:改为：12# Uri of fonts host. E.g. //fonts.googleapis.com (Default)host: //fonts.lug.ustc.edu.cn因为fonts.lug.ustc.edu.cn是中科大的源，相比之前能快一下。二、压缩静态资源hexo-neat插件github地址常规的做法是使用gulp来进行压缩，每次压缩时还需要输入额外的命令，比较繁琐利用gulp和它的一些插件来压缩js、css、img等文件。1、安装hexo-neat插件博客目录下运行1npm install hexo-neat --save如果报错，选择克隆插件，然后手动复制到插件目录里面hexo目录\node_modules\1git clone https://github.com/rozbo/hexo-neat2、站点文件配置配置信息添加到博客目录文件夹下的hexo目录\_config.yml的末尾，可以安装自己的需求去自定义配置：12345678910111213141516171819202122232425262728293031# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: # 是否启用，默认true enable: true # 打印日志，默认true logger: true # 排除文件，注意：这里参数太多，看'https://github.com/kangax/html-minifier' exclude:# 压缩css neat_css: enable: true logger: true exclude: - '**/*.min.css'# 压缩jsneat_js: enable: true # Mangle file names mangle: true logger: true # 输出配置 output: # 编译配置 compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js'3、报错及相应解决a) 跳过压缩文件的正确配置方式如果按照官方插件的文档说明来配置exclude，你会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下：1234neat_css:enable: trueexclude: - '**/*.min.css'b) 压缩html时不要跳过.md文件.md文件就是我们写文章时的markdown文件，如果跳过压缩.md文件，而你又刚好在文章中使用到了NexT自带的tab标签，那么当hexo在生成静态页面时就会发生解析错误。这会导致使用到了tab标签的页面生成失败而无法访问。c) 压缩html时不要跳过.swig文件.swig文件是模板引擎文件，简单的说hexo可以通过这些文件来生成对应的页面。如果跳过这些文件，那么你将会发现，你的所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。d) 点击的桃心效果消失1234567891011# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js' - '**/love.js'gitalk js文件报错在上面的代码底部加入如下代码1- '**/comments.gitalk.js'e) jquery pjax min js报错我这里的 jquery pjax min js是指的加入pjax前需要以来的两个cdn文件，一个是jq，一个是它，我将它下载到了本地，不要在意这些细节~同样加入如下代码1- '**/jquery_pjax_min_js.js'4、重新生成123hexo cleanhexo ghexo s清除缓存，重新生成静态页面，启动服务访问可疑发现我们的html页面，css样式文件和js脚本文件都被压缩了，问价大小相比之前小了不少。三、图片懒加载懒加载，在需要的时候才加载图片，而不是一次性加载完整个页面的图片，使用lazyload插件，适用于本地图片很多的情况1、安装lazyload插件在Hexo博客目录下，执行以下命令：1npm install hexo-lazyload --save2、站点文件配置然后在你的 Hexo目录的配置文件 _config.yml 中添加配置:1234lazyload: enable: true # className: #可选 e.g. .J-lazyload-img # loadingImg: #可选 eg. ./images/loading.png参数：loadingImg - 图片未加载时的代替图默认路径: /js/lazyload-plugin/loading.svg如果需要自定义，添填入 loading 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。className - 需要延迟加载的图片 class选择器默认会延迟加载文章中的所有图片。如果不为空，请填入需要延迟加载的图片class 选择器]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo：文章图片问题]]></title>
    <url>%2F2017-01-01%2FHexo%EF%BC%9A%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[Hexo 文章图片问题问题在使用Hexo生成Markdown文档为html后，部署访问刚刚发布的文章，原本文章中引用的图片全部404。解决首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder，当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。安装hexo-asset-image插件在hexo的目录下执行npm install hexo-asset-image --save（需要等待一段时间）。hexo new [layout]新建文章完成安装后用hexo命令新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下：12345test├── 1.jpg├── 2.jpg└── 3.jpgtest.md这样的目录结构（目录名和文章名一致），只要使用 ![logo](本地图片测试/logo.jpg) 就可以插入图片。其中[]里面不写文字则没有图片标题。生成的结构为123456public/2017/3/24/test├── 1.jpg├── 2.jpg└── 3.jpgtest.htmlbug解决正常情况来讲生成的test.html中的src引用应该没有问题才对，当时现在里面的url全部都不对，修改node_modules/hexo-asset-image/index.js文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register('after_post_render',function(data) &#123; var config = hexo.config; if (config.post_asset_folder) &#123; var link = data.permalink; var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for (var i = 0; i &lt; toprocess.length; i++) &#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function() &#123; if ($(this).attr('src')) &#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if (!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem) &#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem) &#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if (srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); &#125; $(this).attr('src', config.root + link + src); console.info &amp;&amp; console.info("update link as:--&gt;" + config.root + link + src); &#125; else &#123; console.log('src-------------' + src); console.info &amp;&amp; console.info("no src attr, skipped..."); console.info &amp;&amp; console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;);]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo：Hello World]]></title>
    <url>%2F2017-01-01%2FHexo%EF%BC%9AHello-World.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
